{"content": "## Setup and Development\n\nThis document provides a comprehensive guide for setting up and developing the project. Follow the instructions carefully to ensure a smooth development experience.\n\n### Prerequisites\n\nBefore you begin, ensure you have the following software installed on your system:\n\n- **Rust**: Install Rust using [rustup](https://rustup.rs/). Ensure that you have the latest stable version.\n- **Cargo**: Cargo is the Rust package manager and is installed alongside Rust.\n- **Git**: Version control system to clone the repository.\n- **Node.js and npm**: Required for building web components. Install from [nodejs.org](https://nodejs.org/).\n- **Wasm-pack**: For building WebAssembly components. Install via `cargo install wasm-pack`.\n- **Python**: Required for running some scripts. Ensure Python 3.x is installed.\n\n### Environment Setup\n\n1. **Clone the Repository**: \n   ```\n   git clone https://github.com/a-b-street/abstreet.git\n   cd abstreet\n   ```\n\n2. **Install Rust Toolchain**:\n   Ensure you have the latest Rust toolchain:\n   ```\n   rustup update\n   ```\n\n3. **Install Node.js and npm**:\n   Follow the instructions on [nodejs.org](https://nodejs.org/) to install Node.js, which includes npm.\n\n4. **Install Wasm-pack**:\n   ```\n   cargo install wasm-pack\n   ```\n\n5. **Install Python Packages** (if any scripts require them):\n   ```\n   pip install -r requirements.txt\n   ```\n\n### Dependencies\n\nThe project uses several Rust crates and npm packages. Dependencies are managed through `Cargo.toml` for Rust and `package.json` for JavaScript.\n\n- **Rust Dependencies**: Defined in `Cargo.toml` files located in each crate directory.\n- **JavaScript Dependencies**: Defined in `web/package.json`.\n\nTo install Rust dependencies, simply build the project using Cargo, which will automatically resolve and fetch the necessary crates.\n\nFor JavaScript dependencies, navigate to the `web` directory and run:\n```\nnpm install\n```\n\n### Build Process\n\n1. **Building Rust Components**:\n   Use Cargo to build the Rust components:\n   ```\n   cargo build --release\n   ```\n\n2. **Building Web Components**:\n   Navigate to the `web` directory and use npm to build:\n   ```\n   cd web\n   npm run build\n   ```\n\n3. **Building WebAssembly Components**:\n   Use wasm-pack to build WebAssembly components:\n   ```\n   wasm-pack build --release --target web\n   ```\n\n### Configuration Files\n\nConfiguration files are used to manage various settings and dependencies:\n\n- **Cargo.toml**: Located in each crate directory, it specifies Rust dependencies and build configurations.\n- **package.json**: Located in the `web` directory, it specifies JavaScript dependencies and scripts.\n- **importer.json**: Configuration for the importer tool, specifying paths to required tools like `osmium`.\n\n### Code Style and Standards\n\n- **Rust Code**: Follow the [Rust style guidelines](https://doc.rust-lang.org/1.0.0/style/). Use `rustfmt` to format code:\n  ```\n  cargo fmt\n  ```\n\n- **JavaScript Code**: Follow standard JavaScript style guides. Use `prettier` for formatting:\n  ```\n  npm run fmt\n  ```\n\n- **Documentation**: Write clear and concise documentation for functions and modules using Rust doc comments (`///`).\n\n- **Commit Messages**: Use descriptive commit messages that explain the changes made. Follow the format:\n  ```\n  [Component] Brief description of changes\n  ```\n\nBy following these guidelines and instructions, you can set up and develop the project effectively. For any issues or further assistance, refer to the project's documentation or contact the maintainers.", "cost": {"input_cost": 0.28658, "output_cost": 0.011955, "total_cost": 0.298535}, "tokens": {"input_tokens": 57316, "output_tokens": 797, "total_tokens": 58113}, "messages": [{"role": "user", "content": "# abstutil/Cargo.toml:\n[package]\nname = \"abstutil\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[dependencies]\nanyhow = { workspace = true }\nbincode = { workspace = true }\nenv_logger = { version = \"0.10.1\" }\nfs-err = { workspace = true }\ninstant = { workspace = true }\nitertools = \"0.12.0\"\nlog = { workspace = true }\nnum_cpus = \"1.16.0\"\nscoped_threadpool = \"0.1.9\"\nserde = { workspace = true, features=[\"derive\"] }\nserde_json = { workspace = true }\n\n[target.'cfg(unix)'.dependencies]\ntermion = \"2.0.3\"\n\n[target.'cfg(target_arch = \"wasm32\")'.dependencies]\nconsole_log = \"1.0.0\"\nweb-sys = { workspace = true, features=[\"Location\", \"Window\"] }\n\n\n# Cargo.toml:\n[workspace]\n\nresolver = \"2\"\n\nmembers = [\n  \"abstio\",\n  \"abstutil\",\n  \"apps/*\",\n  \"blockfinding\",\n  \"cli\",\n  \"collisions\",\n  \"convert_osm\",\n  \"headless\",\n  \"importer\",\n  \"kml\",\n  \"map_gui\",\n  \"map_model\",\n  \"piggyback\",\n  \"popdat\",\n  \"popgetter\",\n  \"raw_map\",\n  \"sim\",\n  \"synthpop\",\n  \"tests\",\n  \"traffic_seitan\",\n  \"updater\",\n  \"widgetry\",\n  \"widgetry_demo\",\n]\n\n# See https://doc.rust-lang.org/cargo/reference/profiles.html#overrides. This\n# compiles all external dependencies as release mode, yielding great runtime\n# speed, but only paying the cost of slow compilation once (since we don't\n# update dependencies often).\n[profile.dev.package.\"*\"]\nopt-level = 3\n\n# Specify the versions for common dependencies just once here, instead of\n# repeating in a bunch of crates\n[workspace.dependencies]\nanyhow = \"1.0.75\"\nbincode = \"1.3.1\"\ncolorous = \"1.0.9\"\ncontour = \"0.7.0\"\ncsv = \"1.2.0\"\nflate2 = \"1.0.26\"\nfs-err = \"2.9.0\"\nfutures = { version = \"0.3.27\"}\nfutures-channel = { version = \"0.3.29\"}\ngeo = \"0.27.0\"\ngeojson = { version = \"0.24.1\", features = [\"geo-types\"] }\ngeom = { git = \"https://github.com/a-b-street/geom\" }\ngetrandom = \"0.2.11\"\ninstant = \"0.1.7\"\nlog = \"0.4.20\"\nrand = \"0.8.3\"\nrand_xorshift = \"0.3.0\"\nserde = \"1.0.195\"\nserde_json = \"1.0.108\"\nstructopt = \"0.3.23\"\ntokio = { version = \"1.34.0\", features=[\"full\"] }\nwasm-bindgen = \"0.2.88\"\nweb-sys = \"0.3.65\"\n\n# There's a circular dependency between this repo (abstreet) and osm2streets,\n# due to the 2 core dependency crates listed below. This patch is required to\n# avoid Cargo from getting confused.\n[patch.\"https://github.com/a-b-street/abstreet/\"]\nabstutil = { path = \"abstutil\" }\n\n[patch.crates-io]\nhttp-range-client = { git = \"https://github.com/pka/http-range-client\", rev = \"e62f72ab3553a19f4166f73efd18b13b4c4164ec\" }\n\n# To temporarily work on dependencies locally, uncomment this\n# TODO Do not commit. Update each repo\n#[patch.\"https://github.com/a-b-street/osm2streets\"]\n#streets_reader = { path = \"/home/dabreegster/osm2streets/streets_reader\" }\n#osm2streets = { path = \"/home/dabreegster/osm2streets/osm2streets\" }\n\n\n# abstio/Cargo.toml:\n[package]\nname = \"abstio\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[dependencies]\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\nbase64 = \"0.21.5\"\nbincode = { workspace = true }\nfs-err = { workspace = true }\ninstant = { workspace = true }\nlog = { workspace = true }\nreqwest = { version = \"0.11.22\", default-features=false, features=[\"rustls-tls\"] }\nserde = { workspace = true, features=[\"derive\"] }\nserde_json = { workspace = true }\n\n[target.'cfg(not(target_arch = \"wasm32\"))'.dependencies]\nfutures-channel = { workspace = true }\n# Don't use workspace, because that includes features=full\ntokio = \"1.34.0\"\n\n[target.'cfg(target_arch = \"wasm32\")'.dependencies]\ninclude_dir = { git = \"https://github.com/dabreegster/include_dir\", branch = \"union\" }\njs-sys = \"0.3.65\"\nwasm-bindgen = { workspace = true }\nweb-sys = { workspace = true, features=[\"HtmlElement\", \"Storage\", \"Window\"] }\n\n\n# widgetry_demo/Cargo.toml:\n[package]\nname = \"widgetry_demo\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\", \"lib\"]\n\n[features]\ndefault = [\"widgetry/native-backend\"]\nwasm = [\"getrandom/js\", \"wasm-bindgen\", \"widgetry/wasm-backend\"]\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\ngeom = { workspace = true }\ngetrandom = { workspace = true, optional = true }\nlog = { workspace = true }\nrand = { workspace = true }\nrand_xorshift = { workspace = true }\nsvg_face = \"0.1.3\"\nwasm-bindgen = { workspace = true, optional = true }\nwidgetry = { path = \"../widgetry\" }\n\n\n# importer/Cargo.toml:\n[package]\nname = \"importer\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[features]\ndefault = []\nscenarios = [\"gdal\"]\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\ncollisions = { path = \"../collisions\" }\nconvert_osm = { path = \"../convert_osm\" }\ncsv = { workspace = true }\nfs-err = { workspace = true }\ngeo = { workspace = true }\ngeojson = { workspace = true }\ngeom = { workspace = true }\ngdal = { version = \"0.14.0\", optional = true, features = [\"bindgen\"] }\nkml = { path = \"../kml\" }\nlog = { workspace = true }\nmap_model = { path = \"../map_model\" }\npopdat = { path = \"../popdat\" }\nrand  = \"0.8.3\"\nrand_xorshift = { workspace = true }\nraw_map = { path = \"../raw_map\" }\nserde = { workspace = true, features=[\"derive\"] }\nserde_json = { workspace = true }\nsim = { path = \"../sim\" }\nosm2streets = { git = \"https://github.com/a-b-street/osm2streets\" }\nsynthpop = { path = \"../synthpop\" }\nstructopt = { workspace = true }\n\n\n# importer/external_scenarios.sh:\n#!/bin/bash\n# Scenarios for some cities are based on JSON files produced by external travel\n# demand models, such as https://github.com/a-b-street/abstr. This script\n# re-imports all of them. When a map's road or intersection IDs change, this\n# must be re-run, or the binary scenario will get out-of-sync.\n\nset -e\n\n# Keep this list in sync with release/deploy_actdev.sh\nfor city in allerton_bywater ashton_park aylesbury aylesham bailrigg bath_riverside bicester castlemead chapelford chapeltown_cohousing clackers_brook cricklewood culm dickens_heath didcot dunton_hills ebbsfleet exeter_red_cow_village great_kneighton halsnead hampton handforth kergilliack kidbrooke_village lcid lockleaze long_marston marsh_barton micklefield newborough_road newcastle_great_park northwick_park poundbury priors_hall taunton_firepool taunton_garden tresham trumpington_meadows tyersal_lane upton water_lane wichelstowe wixams wynyard; do\n\t./importer/actdev_scenario.sh $city;\ndone\n\n\n# importer/actdev_scenario.sh:\n#!/bin/bash\n# Generate scenarios for ActDev maps, using scenario JSON files from\n# https://github.com/cyipt/actdev/tree/main/data-small.\n\nset -e\n\nCITY=$1\nif [ \"$CITY\" == \"\" ]; then\n\techo Missing args;\n\texit 1;\nfi\nSITE=`echo $CITY | sed -r 's/_/-/g'`\n\n# Import the scenarios\nrm -fv *.json\nwget https://raw.githubusercontent.com/cyipt/actdev/main/data-small/$SITE/scenario_base.json\nwget https://raw.githubusercontent.com/cyipt/actdev/main/data-small/$SITE/scenario_go_active.json\n\ncargo run --release --bin cli -- import-scenario --map=data/system/gb/$CITY/maps/center.bin --input=scenario_base.json --skip_problems\ncargo run --release --bin cli -- import-scenario --map=data/system/gb/$CITY/maps/center.bin --input=scenario_go_active.json --skip_problems\nrm -fv *.json\ncargo run --release --bin cli -- augment-scenario --input-scenario=data/system/gb/$CITY/scenarios/center/base.bin --add-return-trips --add-lunch-trips\ncargo run --release --bin cli -- augment-scenario --input-scenario=data/system/gb/$CITY/scenarios/center/go_active.bin --add-return-trips --add-lunch-trips\n# Generate the background traffic from OD data, and mix it in with the two actdev scenarios\n./import.sh --scenario --city=gb/$CITY\n\n\n# importer/actdev_site.sh:\n#!/bin/bash\n# This script imports a site from\n# https://github.com/cyipt/actdev/tree/main/data-small as a new city.\n\nset -e\n\n# This should be a directory name from https://github.com/cyipt/actdev/tree/main/data-small\nSITE=$1\nif [ \"$SITE\" == \"\" ]; then\n\techo Missing args;\n\texit 1;\nfi\nCITY=`echo $SITE | sed -r 's/-/_/g'`\n\n# Follow https://a-b-street.github.io/docs/user/new_city.html and import as a new city.\nmkdir -p importer/config/gb/$CITY\nwget https://raw.githubusercontent.com/cyipt/actdev/main/data-small/$SITE/small-study-area.geojson\nmv small-study-area.geojson importer/config/gb/$CITY/center.geojson\n\nwget https://raw.githubusercontent.com/cyipt/actdev/main/data-small/$SITE/site.geojson -O data/system/study_areas/$SITE.geojson\n\n./import.sh --raw --map --city=gb/$CITY\n\n# Note we once ran 'generate-houses'; see version history for context\n\n./importer/actdev_scenario.sh $CITY\n\necho \"You have to manually update .gitignore, map_gui/src/tools/mod.rs, release/deploy_actdev.sh\"\necho \"And after uploading, probably want to: cargo run --bin updater -- opt-into-all > data/player/data.json\"\n\n\n# importer/sao_miguel_paulista_scenario.sh:\n#!/bin/bash\n# Generates a scenario from external JSON data, for\n# https://github.com/a-b-street/abstreet/issues/861.\n#\n# Along with actdev_scenario.sh, this should eventually be expressed as part of\n# the Rust pipeline directly somehow, so that --scenario uses the original data\n# (or a cached S3 version, rather)\n\nset -e\n\nwget https://github.com/spstreets/OD2017/releases/download/1/all_trips.json\ncargo run --release --bin cli -- import-scenario --map=data/system/br/sao_paulo/maps/sao_miguel_paulista.bin --input=all_trips.json\n# Cancel 80% of all driving trips, so the scenario doesn't gridlock\ncargo run --release --bin cli -- augment-scenario --input-scenario=data/system/br/sao_paulo/scenarios/sao_miguel_paulista/Full.bin --scenario-modifiers='[{\"ChangeMode\":{\"pct_ppl\":80,\"departure_filter\":[0,864000000],\"from_modes\":[\"Drive\"],\"to_mode\":null}}]' --delete-cancelled-trips\n\n\n# importer/src/lib.rs:\n//! It's assumed that the importer is run with the current directory as the project repository; aka\n//! `./data/` and `./importer/config` must exist.\n\n// Disable some noisy clippy lints\n#![allow(clippy::type_complexity)]\n\n#[macro_use]\nextern crate anyhow;\n#[macro_use]\nextern crate log;\n\nuse structopt::StructOpt;\n\nuse abstio::{CityName, MapName};\nuse abstutil::Timer;\nuse map_model::RawToMapOptions;\n\npub use self::configuration::ImporterConfiguration;\npub use self::pick_geofabrik::pick_geofabrik;\npub use utils::osmium;\n\nmod berlin;\nmod configuration;\nmod map_config;\nmod pick_geofabrik;\nmod seattle;\nmod soundcast;\nmod uk;\nmod utils;\n\n/// Regenerate all maps and scenarios from scratch.\npub async fn regenerate_everything(shard_num: usize, num_shards: usize) {\n    // Discover all cities by looking at config. But always operate on Seattle first. Special\n    // treatment ;)\n    let mut all_cities = CityName::list_all_cities_from_importer_config();\n    all_cities.retain(|x| x != &CityName::seattle());\n    all_cities.insert(0, CityName::seattle());\n\n    let mut timer = Timer::new(\"regenerate all maps\");\n    for (cnt, city) in all_cities.into_iter().enumerate() {\n        if cnt % num_shards == shard_num {\n            let job = Job::full_for_city(city);\n            job.run(&mut timer).await;\n        }\n    }\n}\n\n/// Transforms a .osm.xml or .pbf file to a map in one step.\npub async fn oneshot(\n    osm_path: String,\n    clip: Option<String>,\n    options: convert_osm::Options,\n    create_uk_travel_demand_model: bool,\n    opts: RawToMapOptions,\n) {\n    let mut timer = abstutil::Timer::new(\"oneshot\");\n    println!(\"- Running convert_osm on {}\", osm_path);\n    let name = abstutil::basename(&osm_path);\n    let raw = convert_osm::convert(\n        osm_path,\n        MapName::new(\"zz\", \"oneshot\", &name),\n        clip,\n        options,\n        &mut timer,\n    );\n    // Often helpful to save intermediate representation in case user wants to load into map_editor\n    raw.save();\n    let map = map_model::Map::create_from_raw(raw, opts, &mut timer);\n    timer.start(\"save map\");\n    map.save();\n    timer.stop(\"save map\");\n\n    if create_uk_travel_demand_model {\n        timer.start(\"generating UK travel demand model\");\n        uk::generate_scenario(&map, &ImporterConfiguration::load(), &mut timer)\n            .await\n            .unwrap();\n        timer.stop(\"generating UK travel demand model\");\n    }\n\n    println!(\"{} has been created\", map.get_name().path());\n}\n\n/// A specification for importing all maps in a single city.\n#[derive(StructOpt)]\npub struct Job {\n    #[structopt(long, parse(try_from_str = CityName::parse), default_value = \"us/seattle\")]\n    pub city: CityName,\n    /// Download all raw input files, then convert OSM to the intermediate RawMap.\n    #[structopt(long = \"--raw\")]\n    pub osm_to_raw: bool,\n    /// Convert the RawMap to the final Map format.\n    #[structopt(long = \"--map\")]\n    pub raw_to_map: bool,\n    /// Download trip demand data, then produce the typical weekday scenario.\n    #[structopt(long)]\n    pub scenario: bool,\n    /// Produce a city overview from all of the individual maps in a city.\n    #[structopt(long)]\n    pub city_overview: bool,\n\n    /// Only process one map. If not specified, process all maps defined by clipping polygons in\n    /// importer/config/$city/.\n    #[structopt()]\n    pub only_map: Option<String>,\n\n    #[structopt(flatten)]\n    pub opts: RawToMapOptions,\n}\n\nimpl Job {\n    pub fn full_for_city(city: CityName) -> Job {\n        let mut job = Job {\n            city: city,\n            osm_to_raw: true,\n            raw_to_map: true,\n            scenario: false,\n            city_overview: false,\n            only_map: None,\n            opts: RawToMapOptions::default(),\n        };\n        // Only some maps run extra tasks\n        if job.city == CityName::seattle() || job.city.country == \"gb\" {\n            job.scenario = true;\n        }\n        // TODO Autodetect this based on number of maps per city?\n        if job.city == CityName::new(\"ch\", \"zurich\")\n            || job.city == CityName::new(\"gb\", \"leeds\")\n            || job.city == CityName::new(\"gb\", \"london\")\n            || job.city == CityName::new(\"us\", \"nyc\")\n            || job.city == CityName::new(\"fr\", \"charleville_mezieres\")\n            || job.city == CityName::new(\"fr\", \"paris\")\n            || job.city == CityName::new(\"at\", \"salzburg\")\n            || job.city == CityName::new(\"ir\", \"tehran\")\n            || job.city == CityName::new(\"pt\", \"portugal\")\n        {\n            job.city_overview = true;\n        }\n        job\n    }\n\n    /// Return the command-line flags that should produce this job. Incomplete -- doesn't invert\n    /// RawToMapOptions\n    pub fn flags(&self) -> Vec<String> {\n        // TODO Can structopt do the inversion?\n        let mut flags = vec![];\n        flags.push(format!(\"--city={}\", self.city.to_path()));\n        if self.osm_to_raw {\n            flags.push(\"--raw\".to_string());\n        }\n        if self.raw_to_map {\n            flags.push(\"--map\".to_string());\n        }\n        if self.scenario {\n            flags.push(\"--scenario\".to_string());\n        }\n        if self.city_overview {\n            flags.push(\"--city-overview\".to_string());\n        }\n        if let Some(ref name) = self.only_map {\n            flags.push(name.clone());\n        }\n        flags\n    }\n\n    pub async fn run(self, timer: &mut Timer<'_>) {\n        if !self.osm_to_raw && !self.raw_to_map && !self.scenario && !self.city_overview {\n            println!(\n                \"Nothing to do! Pass some combination of --raw, --map, --scenario, or --city_overview\"\n            );\n            std::process::exit(1);\n        }\n\n        let config = ImporterConfiguration::load();\n\n        timer.start(format!(\"import {}\", self.city.describe()));\n        let names = if let Some(n) = self.only_map {\n            println!(\"- Just working on {}\", n);\n            vec![MapName::from_city(&self.city, &n)]\n        } else {\n            println!(\"- Working on all {} maps\", self.city.describe());\n            self.city.list_all_maps_in_city_from_importer_config()\n        };\n\n        // When regenerating everything, huge_seattle gets created twice! This is expensive enough\n        // to hack in a way to avoid the work.\n        let mut built_raw_huge_seattle = false;\n        let mut built_map_huge_seattle = false;\n        let (maybe_popdat, maybe_huge_map, maybe_zoning_parcels) = if self.scenario\n            && self.city == CityName::seattle()\n        {\n            timer.start(\"ensure_popdat_exists\");\n            let (popdat, huge_map) = seattle::ensure_popdat_exists(\n                timer,\n                &config,\n                &mut built_raw_huge_seattle,\n                &mut built_map_huge_seattle,\n            )\n            .await;\n            // Just assume --raw has been called...\n            let shapes: kml::ExtraShapes =\n                abstio::read_binary(CityName::seattle().input_path(\"zoning_parcels.bin\"), timer);\n            timer.stop(\"ensure_popdat_exists\");\n            (Some(popdat), Some(huge_map), Some(shapes))\n        } else {\n            (None, None, None)\n        };\n\n        for name in names {\n            timer.start(name.describe());\n            if self.osm_to_raw\n                && (!built_raw_huge_seattle || name != MapName::seattle(\"huge_seattle\"))\n            {\n                let raw = utils::osm_to_raw(name.clone(), timer, &config).await;\n\n                // The collision data will only cover one part of London, since we don't have a\n                // region-wide map there yet\n                if name.city == CityName::new(\"de\", \"berlin\") {\n                    berlin::import_extra_data(&raw, &config, timer).await;\n                } else if name == MapName::new(\"gb\", \"leeds\", \"huge\") {\n                    uk::import_collision_data(&raw, &config, timer).await;\n                } else if name == MapName::new(\"gb\", \"london\", \"camden\") {\n                    uk::import_collision_data(&raw, &config, timer).await;\n                }\n            }\n\n            let mut maybe_map = if self.raw_to_map {\n                let mut map = if built_map_huge_seattle && name == MapName::seattle(\"huge_seattle\")\n                {\n                    map_model::Map::load_synchronously(name.path(), timer)\n                } else {\n                    utils::raw_to_map(&name, self.opts.clone(), timer)\n                };\n\n                // Another strange step in the pipeline.\n                if name == MapName::new(\"de\", \"berlin\", \"center\") {\n                    timer.start(format!(\n                        \"distribute residents from planning areas for {}\",\n                        name.describe()\n                    ));\n                    berlin::distribute_residents(&mut map, timer);\n                    timer.stop(format!(\n                        \"distribute residents from planning areas for {}\",\n                        name.describe()\n                    ));\n\n                    map.save();\n                }\n\n                Some(map)\n            } else if self.scenario {\n                Some(map_model::Map::load_synchronously(name.path(), timer))\n            } else {\n                None\n            };\n\n            if self.scenario {\n                if self.city == CityName::seattle() {\n                    timer.start(format!(\"scenario for {}\", name.describe()));\n                    let scenario = soundcast::make_scenario(\n                        \"weekday\",\n                        maybe_map.as_ref().unwrap(),\n                        maybe_popdat.as_ref().unwrap(),\n                        maybe_huge_map.as_ref().unwrap(),\n                        timer,\n                    );\n                    scenario.save();\n                    timer.stop(format!(\"scenario for {}\", name.describe()));\n\n                    // This is a strange ordering.\n                    if name.map == \"downtown\"\n                        || name.map == \"qa\"\n                        || name.map == \"south_seattle\"\n                        || name.map == \"wallingford\"\n                    {\n                        timer.start(format!(\"adjust parking for {}\", name.describe()));\n                        seattle::adjust_private_parking(maybe_map.as_mut().unwrap(), &scenario);\n                        timer.stop(format!(\"adjust parking for {}\", name.describe()));\n                    }\n\n                    timer.start(\"match parcels to buildings\");\n                    seattle::match_parcels_to_buildings(\n                        maybe_map.as_mut().unwrap(),\n                        maybe_zoning_parcels.as_ref().unwrap(),\n                        timer,\n                    );\n                    timer.stop(\"match parcels to buildings\");\n\n                    // Even stranger hacks! AFTER generating the scenarios, which requires full\n                    // pathfinding, for a few maps, \"minify\" them to cut down file size for the\n                    // bike network tool.\n                    if name.map == \"central_seattle\"\n                        || name.map == \"north_seattle\"\n                        || name.map == \"south_seattle\"\n                    {\n                        let map = maybe_map.as_mut().unwrap();\n                        map.minify(timer);\n                        map.save();\n                    }\n                }\n\n                if self.city.country == \"gb\" {\n                    if name == MapName::new(\"gb\", \"london\", \"central\") {\n                        // No scenario for Central London, which has buildings stripped out\n                        let map = maybe_map.as_mut().unwrap();\n                        map.minify_buildings(timer);\n                        map.save();\n                    } else {\n                        uk::generate_scenario(maybe_map.as_ref().unwrap(), &config, timer)\n                            .await\n                            .unwrap();\n                    }\n                }\n            }\n            timer.stop(name.describe());\n        }\n\n        if self.city_overview {\n            timer.start(format!(\n                \"generate city overview for {}\",\n                self.city.describe()\n            ));\n            abstio::write_binary(\n                abstio::path(format!(\n                    \"system/{}/{}/city.bin\",\n                    self.city.country, self.city.city\n                )),\n                &map_model::City::from_individual_maps(&self.city, timer),\n            );\n            timer.stop(format!(\n                \"generate city overview for {}\",\n                self.city.describe()\n            ));\n        }\n\n        timer.stop(format!(\"import {}\", self.city.describe()));\n    }\n}\n\n\n# importer/src/configuration.rs:\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(default)]\npub struct ImporterConfiguration {\n    pub osmium: String,\n    pub unzip: String,\n    pub gunzip: String,\n    pub gunzip_args: String,\n}\n\nimpl Default for ImporterConfiguration {\n    fn default() -> ImporterConfiguration {\n        ImporterConfiguration {\n            osmium: String::from(\"osmium\"),\n            unzip: String::from(\"unzip\"),\n            gunzip: String::from(\"gunzip\"),\n            gunzip_args: String::from(\"\"),\n        }\n    }\n}\n\nimpl ImporterConfiguration {\n    pub fn load() -> Self {\n        // Safe to assume that {} can be parsed given struct-level Default implementation.\n        let default = serde_json::from_str(\"{}\").unwrap();\n\n        match fs_err::read_to_string(\"importer.json\") {\n            Ok(contents) => serde_json::from_str(&contents).unwrap_or(default),\n            Err(_) => default,\n        }\n    }\n}\n\n\n# importer/src/seattle.rs:\nuse std::collections::HashSet;\n\nuse abstio::{CityName, MapName};\nuse abstutil::Timer;\nuse geom::{Polygon, QuadTree, Ring};\nuse kml::ExtraShapes;\nuse map_model::{BuildingID, BuildingType, Map};\nuse sim::count_parked_cars_per_bldg;\nuse synthpop::Scenario;\n\nuse crate::configuration::ImporterConfiguration;\nuse crate::utils::{download, download_kml};\n\npub async fn input(config: &ImporterConfiguration, timer: &mut Timer<'_>) {\n    let city = CityName::seattle();\n\n    // Soundcast data was originally retrieved from staff at PSRC via a download link that didn't\n    // last long. From that original 2014 .zip (possibly still available from\n    // https://github.com/psrc/soundcast/releases), two files were extracted --\n    // parcels_urbansim.txt and trips_2014.csv. Those are now stored in S3. It's a bit weird for\n    // the importer pipeline to depend on something in data/input in S3, but this should let\n    // anybody run the full pipeline.\n    download(\n        config,\n        city.input_path(\"parcels_urbansim.txt\"),\n        \"http://abstreet.s3-website.us-east-2.amazonaws.com/dev/data/input/us/seattle/parcels_urbansim.txt.gz\",\n    )\n    .await;\n    download(\n        config,\n        city.input_path(\"trips_2014.csv\"),\n        \"http://abstreet.s3-website.us-east-2.amazonaws.com/dev/data/input/us/seattle/trips_2014.csv.gz\",\n    )\n    .await;\n\n    let bounds = geom::GPSBounds::from(\n        geom::LonLat::read_geojson_polygon(\"importer/config/us/seattle/huge_seattle.geojson\")\n            .unwrap(),\n    );\n    // From http://data-seattlecitygis.opendata.arcgis.com/datasets/blockface\n    download_kml(\n        city.input_path(\"blockface.bin\"),\n        \"https://opendata.arcgis.com/datasets/a1458ad1abca41869b81f7c0db0cd777_0.kml\",\n        &bounds,\n        true,\n        timer,\n    )\n    .await;\n    // From https://data-seattlecitygis.opendata.arcgis.com/datasets/public-garages-or-parking-lots\n    download_kml(\n        city.input_path(\"offstreet_parking.bin\"),\n        \"http://data-seattlecitygis.opendata.arcgis.com/datasets/8e52dfde6d5d45948f7a90654c8d50cd_0.kml\",\n        &bounds,\n        true,\n        timer\n    ).await;\n\n    // From\n    // https://data-seattlecitygis.opendata.arcgis.com/datasets/5b5c745e0f1f48e7a53acec63a0022ab_0\n    download(\n        config,\n        city.input_path(\"collisions.kml\"),\n        \"https://opendata.arcgis.com/datasets/5b5c745e0f1f48e7a53acec63a0022ab_0.kml\",\n    )\n    .await;\n\n    // This is a little expensive, so delete data/input/us/seattle/collisions.bin to regenerate\n    // this.\n    if !abstio::file_exists(city.input_path(\"collisions.bin\")) {\n        let shapes = kml::load(city.input_path(\"collisions.kml\"), &bounds, true, timer).unwrap();\n        let collisions = collisions::import_seattle(\n            shapes,\n            \"https://data-seattlecitygis.opendata.arcgis.com/datasets/5b5c745e0f1f48e7a53acec63a0022ab_0\");\n        abstio::write_binary(city.input_path(\"collisions.bin\"), &collisions);\n    }\n\n    // From https://data-seattlecitygis.opendata.arcgis.com/datasets/parcels-1\n    download_kml(\n        city.input_path(\"zoning_parcels.bin\"),\n        \"https://opendata.arcgis.com/datasets/42863f1debdc47488a1c2b9edd38053e_2.kml\",\n        &bounds,\n        true,\n        timer,\n    )\n    .await;\n\n    // From\n    // https://data-seattlecitygis.opendata.arcgis.com/datasets/current-land-use-zoning-detail\n    download_kml(\n        city.input_path(\"land_use.bin\"),\n        \"https://opendata.arcgis.com/datasets/dd29065b5d01420e9686570c2b77502b_0.kml\",\n        &bounds,\n        false,\n        timer,\n    )\n    .await;\n}\n\n/// Download and pre-process data needed to generate Seattle scenarios.\npub async fn ensure_popdat_exists(\n    timer: &mut Timer<'_>,\n    config: &ImporterConfiguration,\n    built_raw_huge_seattle: &mut bool,\n    built_map_huge_seattle: &mut bool,\n) -> (crate::soundcast::PopDat, map_model::Map) {\n    let huge_name = MapName::seattle(\"huge_seattle\");\n\n    if abstio::file_exists(abstio::path_popdat()) {\n        println!(\"- {} exists, not regenerating it\", abstio::path_popdat());\n        return (\n            abstio::read_binary(abstio::path_popdat(), timer),\n            map_model::Map::load_synchronously(huge_name.path(), timer),\n        );\n    }\n\n    if !abstio::file_exists(abstio::path_raw_map(&huge_name)) {\n        crate::utils::osm_to_raw(MapName::seattle(\"huge_seattle\"), timer, config).await;\n        *built_raw_huge_seattle = true;\n    }\n    let huge_map = if abstio::file_exists(huge_name.path()) {\n        map_model::Map::load_synchronously(huge_name.path(), timer)\n    } else {\n        *built_map_huge_seattle = true;\n        crate::utils::raw_to_map(&huge_name, map_model::RawToMapOptions::default(), timer)\n    };\n\n    (crate::soundcast::import_data(&huge_map, timer), huge_map)\n}\n\npub fn adjust_private_parking(map: &mut Map, scenario: &Scenario) {\n    for (b, count) in count_parked_cars_per_bldg(scenario).consume() {\n        map.hack_override_offstreet_spots_individ(b, count);\n    }\n    map.save();\n}\n\n/// Match OSM buildings to parcels, scraping the number of housing units.\n// TODO It's expensive to load the huge zoning_parcels.bin file for every map.\npub fn match_parcels_to_buildings(map: &mut Map, shapes: &ExtraShapes, timer: &mut Timer) {\n    let mut parcels_with_housing: Vec<(Polygon, usize)> = Vec::new();\n    // TODO We should refactor something like FindClosest, but for polygon containment\n    // The quadtree's ID is just an index into parcels_with_housing.\n    let mut quadtree = QuadTree::builder();\n    timer.start_iter(\"index all parcels\", shapes.shapes.len());\n    for shape in &shapes.shapes {\n        timer.next();\n        if let Some(units) = shape\n            .attributes\n            .get(\"EXIST_UNITS\")\n            .and_then(|x| x.parse::<usize>().ok())\n        {\n            if let Some(ring) = map\n                .get_gps_bounds()\n                .try_convert(&shape.points)\n                .and_then(|pts| Ring::new(pts).ok())\n            {\n                let polygon = ring.into_polygon();\n                quadtree.add_with_box(parcels_with_housing.len(), polygon.get_bounds());\n                parcels_with_housing.push((polygon, units));\n            }\n        }\n    }\n    let quadtree = quadtree.build();\n\n    let mut used_parcels: HashSet<usize> = HashSet::new();\n    let mut units_per_bldg: Vec<(BuildingID, usize)> = Vec::new();\n    timer.start_iter(\"match buildings to parcels\", map.all_buildings().len());\n    for b in map.all_buildings() {\n        timer.next();\n        // If multiple parcels contain a building's center, just pick one arbitrarily\n        for idx in quadtree.query_bbox(b.polygon.get_bounds()) {\n            if used_parcels.contains(&idx)\n                || !parcels_with_housing[idx].0.contains_pt(b.label_center)\n            {\n                continue;\n            }\n            used_parcels.insert(idx);\n            units_per_bldg.push((b.id, parcels_with_housing[idx].1));\n        }\n    }\n\n    for (b, num_housing_units) in units_per_bldg {\n        let bldg_type = match map.get_b(b).bldg_type.clone() {\n            BuildingType::Residential { num_residents, .. } => BuildingType::Residential {\n                num_housing_units,\n                num_residents,\n            },\n            x => x,\n        };\n        map.hack_override_bldg_type(b, bldg_type);\n    }\n\n    map.save();\n}\n\n\n# importer/src/map_config.rs:\nuse abstio::{CityName, MapName};\nuse geom::Distance;\nuse map_model::DrivingSide;\n\n/// Given the name of a map, configure its import.\n///\n/// Note this was once expressed as config files for every city. That was less maintainable; most\n/// places used default values that were copied around.\n// Slightly more verbose logic feels easier to read\n#[allow(clippy::match_like_matches_macro)]\npub fn config_for_map(name: &MapName) -> convert_osm::Options {\n    convert_osm::Options {\n        map_config: osm2streets::MapConfig {\n            // osm2streets will set this anyway, it doesn't matter here\n            driving_side: DrivingSide::Right,\n            country_code: String::new(),\n            bikes_can_use_bus_lanes: name.city.country != \"pl\",\n            inferred_sidewalks: name.city.country != \"pl\",\n            street_parking_spot_length: if name.city == CityName::new(\"ca\", \"montreal\") {\n                Distance::meters(6.5)\n            } else {\n                Distance::meters(8.0)\n            },\n            turn_on_red: name.city.country == \"us\" && name.city.city != \"nyc\",\n            include_railroads: match name.city.city.as_ref() {\n                \"phoenix\" | \"seattle\" | \"tucson\" => false,\n                _ => {\n                    if name.map == \"hammersmith_and_fulham\" {\n                        // TODO Some movement geometry bug here\n                        false\n                    } else {\n                        true\n                    }\n                }\n            },\n        },\n        filter_crosswalks: false,\n        onstreet_parking: match name.city.city.as_ref() {\n            \"seattle\" => {\n                convert_osm::OnstreetParking::Blockface(name.city.input_path(\"blockface.bin\"))\n            }\n            _ => convert_osm::OnstreetParking::JustOSM,\n        },\n        public_offstreet_parking: if name.city == CityName::seattle() {\n            convert_osm::PublicOffstreetParking::Gis(name.city.input_path(\"offstreet_parking.bin\"))\n        } else {\n            convert_osm::PublicOffstreetParking::None\n        },\n        private_offstreet_parking: if name.city == CityName::seattle() {\n            convert_osm::PrivateOffstreetParking::FixedPerBldg(\n                // TODO Utter guesses or in response to gridlock\n                match name.map.as_ref() {\n                    \"downtown\" => 5,\n                    \"lakeslice\" => 5,\n                    \"qa\" => 5,\n                    \"south_seattle\" => 5,\n                    \"wallingford\" => 5,\n                    _ => 1,\n                },\n            )\n        } else {\n            convert_osm::PrivateOffstreetParking::FixedPerBldg(3)\n        },\n        // Unused currently\n        extra_buildings: None,\n        // https://www.transit.land is a great place to find the static GTFS URLs\n        gtfs_url: if name == &MapName::new(\"us\", \"seattle\", \"arboretum\") {\n            Some(\"http://metro.kingcounty.gov/GTFS/google_transit.zip\".to_string())\n        } else if name.city == CityName::new(\"us\", \"san_francisco\") {\n            None\n            // Crashing the traffic sim, so disabled\n            //Some(\"https://gtfs.sfmta.com/transitdata/google_transit.zip\".to_string())\n        } else if name == &MapName::new(\"br\", \"sao_paulo\", \"aricanduva\") {\n            Some(\"https://github.com/transitland/gtfs-archives-not-hosted-elsewhere/blob/master/sao-paulo-sptrans.zip?raw=true\".to_string())\n        } else if name.city == CityName::new(\"fr\", \"brest\") {\n            Some(\"https://ratpdev-mosaic-prod-bucket-raw.s3-eu-west-1.amazonaws.com/11/exports/1/gtfs.zip\".to_string())\n        } else {\n            None\n        },\n        // We only have a few elevation sources working\n        elevation_geotiff: if name.city == CityName::new(\"us\", \"seattle\") {\n            Some(\"data/input/shared/elevation/king_county_2016_lidar.tif\".to_string())\n        } else if name.city.country == \"gb\" {\n            Some(\"data/input/shared/elevation/UK-dem-50m-4326.tif\".to_string())\n        } else {\n            None\n        },\n    }\n}\n\n\n# importer/src/utils.rs:\nuse std::path::Path;\nuse std::process::Command;\n\nuse abstio::{CityName, MapName};\nuse abstutil::{must_run_cmd, Timer};\nuse map_model::RawToMapOptions;\nuse raw_map::RawMap;\n\nuse crate::configuration::ImporterConfiguration;\n\n/// If the output file doesn't already exist, downloads the URL into that location. Automatically\n/// uncompresses .zip and .gz files. Assumes a proper path is passed in (including data/).\npub async fn download(config: &ImporterConfiguration, output: String, url: &str) {\n    if Path::new(&output).exists() {\n        println!(\"- {} already exists\", output);\n        return;\n    }\n    // Create the directory\n    fs_err::create_dir_all(Path::new(&output).parent().unwrap())\n        .expect(\"Creating parent dir failed\");\n\n    let tmp_file = format!(\"{output}_TMP\");\n    let tmp = &tmp_file;\n    println!(\"- Missing {}, so downloading {}\", output, url);\n    abstio::download_to_file(url, None, tmp).await.unwrap();\n\n    if url.contains(\".zip\") {\n        let unzip_to = if output.ends_with('/') {\n            output\n        } else {\n            // TODO In this case, there's no guarantee there's only one unzipped file and the name\n            // matches!\n            Path::new(&output).parent().unwrap().display().to_string()\n        };\n        println!(\"- Unzipping into {}\", unzip_to);\n        must_run_cmd(Command::new(&config.unzip).arg(tmp).arg(\"-d\").arg(unzip_to));\n        fs_err::remove_file(tmp).unwrap();\n    } else if url.contains(\".gz\") {\n        println!(\"- Gunzipping\");\n        fs_err::rename(tmp, format!(\"{}.gz\", output)).unwrap();\n\n        let mut gunzip_cmd = Command::new(&config.gunzip);\n        for arg in config.gunzip_args.split_ascii_whitespace() {\n            gunzip_cmd.arg(arg);\n        }\n        must_run_cmd(gunzip_cmd.arg(format!(\"{}.gz\", output)));\n    } else {\n        fs_err::rename(tmp, output).unwrap();\n    }\n}\n\n/// If the output file doesn't already exist, downloads the URL into that location. Clips .kml\n/// files and converts to a .bin.\npub async fn download_kml(\n    output: String,\n    url: &str,\n    bounds: &geom::GPSBounds,\n    require_all_pts_in_bounds: bool,\n    timer: &mut Timer<'_>,\n) {\n    assert!(url.ends_with(\".kml\"));\n    if Path::new(&output).exists() {\n        println!(\"- {} already exists\", output);\n        return;\n    }\n    // Create the directory\n    fs_err::create_dir_all(Path::new(&output).parent().unwrap())\n        .expect(\"Creating parent dir failed\");\n\n    let tmp_file = format!(\"{output}_TMP\");\n    let tmp = &tmp_file;\n    if Path::new(&output.replace(\".bin\", \".kml\")).exists() {\n        fs_err::copy(output.replace(\".bin\", \".kml\"), tmp).unwrap();\n    } else {\n        println!(\"- Missing {}, so downloading {}\", output, url);\n        abstio::download_to_file(url, None, tmp).await.unwrap();\n    }\n\n    println!(\"- Extracting KML data\");\n\n    let shapes = kml::load(tmp.to_string(), bounds, require_all_pts_in_bounds, timer).unwrap();\n    abstio::write_binary(output.clone(), &shapes);\n    // Keep the intermediate file; otherwise we inadvertently grab new upstream data when\n    // changing some binary formats\n    fs_err::rename(tmp, output.replace(\".bin\", \".kml\")).unwrap();\n}\n\n/// Uses osmium to clip the input .osm.xml or osm.pbf against a polygon and produce some output pbf\n/// file. Skips if the output exists.\npub fn osmium(\n    input: String,\n    clipping_polygon: String,\n    output: String,\n    config: &ImporterConfiguration,\n) {\n    if Path::new(&output).exists() {\n        println!(\"- {} already exists\", output);\n        return;\n    }\n    // Create the output directory if needed\n    fs_err::create_dir_all(Path::new(&output).parent().unwrap())\n        .expect(\"Creating parent dir failed\");\n\n    println!(\"- Clipping {} to {}\", input, clipping_polygon);\n\n    // --strategy complete_ways is default\n    must_run_cmd(\n        Command::new(&config.osmium)\n            .arg(\"extract\")\n            .arg(\"-p\")\n            .arg(clipping_polygon)\n            .arg(input)\n            .arg(\"-o\")\n            .arg(output)\n            .arg(\"-f\")\n            // Smaller files without author, timestamp, version\n            .arg(\"pbf,add_metadata=false\"),\n    );\n}\n\n/// Creates a RawMap from OSM and other input data.\npub async fn osm_to_raw(\n    name: MapName,\n    timer: &mut abstutil::Timer<'_>,\n    config: &ImporterConfiguration,\n) -> RawMap {\n    if name.city == CityName::seattle() {\n        crate::seattle::input(config, timer).await;\n    }\n    let opts = crate::map_config::config_for_map(&name);\n    if let Some(ref url) = opts.gtfs_url {\n        download(config, name.city.input_path(\"gtfs/\"), url).await;\n    }\n\n    let boundary_polygon = format!(\n        \"importer/config/{}/{}/{}.geojson\",\n        name.city.country, name.city.city, name.map\n    );\n    let (osm_url, local_osm_file) = crate::pick_geofabrik(boundary_polygon.clone())\n        .await\n        .unwrap();\n    download(config, local_osm_file.clone(), &osm_url).await;\n\n    osmium(\n        local_osm_file,\n        boundary_polygon.clone(),\n        name.city.input_path(format!(\"osm/{}.osm.pbf\", name.map)),\n        config,\n    );\n\n    let map = convert_osm::convert(\n        name.city.input_path(format!(\"osm/{}.osm.pbf\", name.map)),\n        name.clone(),\n        Some(boundary_polygon),\n        opts,\n        timer,\n    );\n    map.save();\n    map\n}\n\n/// Converts a RawMap to a Map.\npub fn raw_to_map(name: &MapName, opts: RawToMapOptions, timer: &mut Timer) -> map_model::Map {\n    timer.start(format!(\"Raw->Map for {}\", name.describe()));\n    let raw: RawMap = abstio::read_binary(abstio::path_raw_map(name), timer);\n    let map = map_model::Map::create_from_raw(raw, opts, timer);\n    timer.start(\"save map\");\n    map.save();\n    timer.stop(\"save map\");\n    timer.stop(format!(\"Raw->Map for {}\", name.describe()));\n\n    // TODO Just sticking this here for now\n    if name.map == \"huge_seattle\" || name == &MapName::new(\"gb\", \"leeds\", \"huge\") {\n        timer.start(\"generating city manifest\");\n        abstio::write_binary(\n            abstio::path(format!(\n                \"system/{}/{}/city.bin\",\n                map.get_city_name().country,\n                map.get_city_name().city\n            )),\n            &map_model::City::from_huge_map(&map),\n        );\n        timer.stop(\"generating city manifest\");\n    }\n\n    map\n}\n\n\n# importer/src/uk.rs:\nuse std::collections::HashMap;\n\nuse anyhow::Result;\nuse fs_err::File;\nuse rand::SeedableRng;\nuse rand_xorshift::XorShiftRng;\nuse serde::Deserialize;\n\nuse abstio::path_shared_input;\nuse abstutil::{prettyprint_usize, Timer};\nuse geom::{GPSBounds, Polygon};\nuse map_model::Map;\nuse popdat::od::DesireLine;\nuse raw_map::RawMap;\nuse synthpop::{Scenario, TrafficCounts, TripEndpoint, TripMode};\n\nuse crate::configuration::ImporterConfiguration;\nuse crate::utils::download;\n\npub async fn import_collision_data(\n    map: &RawMap,\n    config: &ImporterConfiguration,\n    timer: &mut Timer<'_>,\n) {\n    download(\n        config,\n        path_shared_input(\"Road Safety Data - Accidents 2019.csv\"),\n        \"http://data.dft.gov.uk.s3.amazonaws.com/road-accidents-safety-data/DfTRoadSafety_Accidents_2019.zip\").await;\n\n    // Always do this, it's idempotent and fast\n    let shapes = kml::ExtraShapes::load_csv(\n        path_shared_input(\"Road Safety Data - Accidents 2019.csv\"),\n        &map.streets.gps_bounds,\n        timer,\n    )\n    .unwrap();\n    let collisions = collisions::import_stats19(\n        shapes,\n        \"http://data.dft.gov.uk.s3.amazonaws.com/road-accidents-safety-data/DfTRoadSafety_Accidents_2019.zip\");\n    abstio::write_binary(\n        map.get_city_name().input_path(\"collisions.bin\"),\n        &collisions,\n    );\n}\n\npub async fn generate_scenario(\n    map: &Map,\n    config: &ImporterConfiguration,\n    timer: &mut Timer<'_>,\n) -> Result<()> {\n    timer.start(\"prepare input\");\n    download(\n        config,\n        path_shared_input(\"wu03ew_v2.csv\"),\n        \"https://s3-eu-west-1.amazonaws.com/statistics.digitalresources.jisc.ac.uk/dkan/files/FLOW/wu03ew_v2/wu03ew_v2.csv\").await;\n    // https://mapit.mysociety.org/area/45350.html (for geocode) E02004277 is an example place to\n    // debug where these zones are.\n    download(\n        config,\n        path_shared_input(\"zones_core.geojson\"),\n        \"https://github.com/cyipt/actdev/releases/download/0.1.13/zones_core.geojson\",\n    )\n    .await;\n\n    let desire_lines = parse_desire_lines(path_shared_input(\"wu03ew_v2.csv\"))?;\n    let zones = parse_zones(\n        map.get_gps_bounds(),\n        path_shared_input(\"zones_core.geojson\"),\n    )?;\n    timer.stop(\"prepare input\");\n\n    timer.start(\"disaggregate\");\n    // Could plumb this in as a flag to the importer, but it's not critical.\n    let mut rng = XorShiftRng::seed_from_u64(42);\n    let mut scenario = Scenario::empty(map, \"background\");\n    // Include all buses/trains\n    scenario.only_seed_buses = None;\n    scenario.people = popdat::od::disaggregate(\n        map,\n        zones,\n        desire_lines,\n        popdat::od::Options::default(),\n        &mut rng,\n        timer,\n    );\n    // Some zones have very few buildings, and people wind up with a home and workplace that're the\n    // same!\n    scenario = scenario.remove_weird_schedules(false);\n    // TODO For temporary development of the UK OD pipeline...\n    if false {\n        check_sensor_data(map, &scenario, \"/home/dabreegster/sensors.json\", timer);\n    }\n    info!(\n        \"Generated background traffic scenario with {} people\",\n        prettyprint_usize(scenario.people.len())\n    );\n    timer.stop(\"disaggregate\");\n\n    // Does this map belong to the actdev project?\n    match load_study_area(map) {\n        Ok(study_area) => {\n            // Remove people from the scenario we just generated that live in the study area. The\n            // data imported using importer/actdev_scenarios.sh already covers them.\n            let before = scenario.people.len();\n            scenario.people.retain(|p| match p.trips[0].origin {\n                TripEndpoint::Building(b) => !study_area.contains_pt(map.get_b(b).polygon.center()),\n                _ => true,\n            });\n            info!(\n                \"Removed {} people from the background scenario that live in the study area\",\n                prettyprint_usize(before - scenario.people.len())\n            );\n\n            // Create two scenarios, merging the background traffic with the base/active scenarios.\n            let mut base: Scenario = abstio::maybe_read_binary::<Scenario>(\n                abstio::path_scenario(map.get_name(), \"base\"),\n                timer,\n            )?;\n            base.people.extend(scenario.people.clone());\n            base.scenario_name = \"base_with_bg\".to_string();\n            base.save();\n\n            let mut go_active: Scenario = abstio::maybe_read_binary(\n                abstio::path_scenario(map.get_name(), \"go_active\"),\n                timer,\n            )?;\n            go_active.people.extend(scenario.people);\n            go_active.scenario_name = \"go_active_with_bg\".to_string();\n            go_active.save();\n\n            // Don't save background.bin for actdev sites -- use base_with_bg instead.\n        }\n        Err(err) => {\n            // We're a \"normal\" city -- just save the background traffic.\n            info!(\"{} has no study area: {}\", map.get_name().describe(), err);\n            scenario.save();\n        }\n    }\n\n    Ok(())\n}\n\nfn parse_desire_lines(path: String) -> Result<Vec<DesireLine>> {\n    let mut output = Vec::new();\n    for rec in csv::Reader::from_reader(File::open(path)?).deserialize() {\n        let rec: Record = rec?;\n        for (mode, number_commuters) in [\n            (TripMode::Drive, rec.num_drivers),\n            (TripMode::Bike, rec.num_bikers),\n            (TripMode::Walk, rec.num_pedestrians),\n            (\n                TripMode::Transit,\n                rec.num_transit1 + rec.num_transit2 + rec.num_transit3,\n            ),\n        ] {\n            if number_commuters > 0 {\n                output.push(DesireLine {\n                    home_zone: rec.home_zone.clone(),\n                    work_zone: rec.work_zone.clone(),\n                    mode,\n                    number_commuters,\n                });\n            }\n        }\n    }\n    Ok(output)\n}\n\n// An entry in wu03ew_v2.csv. For now, ignores people who work from home, take a taxi, motorcycle,\n// are a passenger in a car, or use \"another method of travel\".\n#[derive(Debug, Deserialize)]\nstruct Record {\n    #[serde(rename = \"Area of residence\")]\n    home_zone: String,\n    #[serde(rename = \"Area of workplace\")]\n    work_zone: String,\n    #[serde(rename = \"Underground, metro, light rail, tram\")]\n    num_transit1: usize,\n    #[serde(rename = \"Train\")]\n    num_transit2: usize,\n    #[serde(rename = \"Bus, minibus or coach\")]\n    num_transit3: usize,\n    #[serde(rename = \"Driving a car or van\")]\n    num_drivers: usize,\n    #[serde(rename = \"Bicycle\")]\n    num_bikers: usize,\n    #[serde(rename = \"On foot\")]\n    num_pedestrians: usize,\n}\n\n// Transforms all zones into the map's coordinate space, no matter how far out-of-bounds they are.\nfn parse_zones(gps_bounds: &GPSBounds, path: String) -> Result<HashMap<String, Polygon>> {\n    let mut zones = HashMap::new();\n    let require_in_bounds = false;\n    for (polygon, tags) in\n        Polygon::from_geojson_bytes(&abstio::slurp_file(path)?, gps_bounds, require_in_bounds)?\n    {\n        if let Some(code) = tags.get(\"geo_code\") {\n            zones.insert(code.to_string(), polygon);\n        } else {\n            bail!(\"Input is missing geo_code: {:?}\", tags);\n        }\n    }\n    Ok(zones)\n}\n\nfn load_study_area(map: &Map) -> Result<Polygon> {\n    let require_in_bounds = true;\n    let mut list = Polygon::from_geojson_bytes(\n        &abstio::slurp_file(abstio::path(format!(\n            \"system/study_areas/{}.geojson\",\n            map.get_name().city.city.replace(\"_\", \"-\")\n        )))?,\n        map.get_gps_bounds(),\n        require_in_bounds,\n    )?;\n    if list.len() != 1 {\n        bail!(\"study area geojson has {} polygons\", list.len());\n    }\n    Ok(list.pop().unwrap().0)\n}\n\nfn check_sensor_data(map: &Map, scenario: &Scenario, sensor_path: &str, timer: &mut Timer) {\n    use map_model::PathRequest;\n\n    let requests = scenario\n        .all_trips()\n        .filter_map(|trip| {\n            if trip.mode == TripMode::Drive {\n                TripEndpoint::path_req(trip.origin, trip.destination, trip.mode, map)\n            } else {\n                None\n            }\n        })\n        .collect();\n    let deduped = PathRequest::deduplicate(map, requests);\n    let model = TrafficCounts::from_path_requests(\n        map,\n        \"the generated scenario\".to_string(),\n        &deduped,\n        map.get_pathfinder(),\n        timer,\n    );\n\n    let sensors = abstio::maybe_read_json::<TrafficCounts>(sensor_path.to_string(), timer).unwrap();\n    sensors.quickly_compare(&model);\n}\n\n\n# web/bin/build-wasm:\n#!/bin/bash\nset -euf -o pipefail\n\nPROJECT_ROOT=$(git rev-parse --show-toplevel)\n\nBIN_NAME=$0\nfunction usage {\n    cat <<EOS\nUsage:\n    $BIN_NAME <crate name> <js pkg name if different from crate name>\nExample:\n    $BIN_NAME widgetry_demo\n    $BIN_NAME game abstreet\nEOS\n}\n\nif [ $# -eq 0 ]; then\n    usage\n    exit1\nfi\n\nCRATE_NAME=\"${1}\"\n\nshift\n\nif [ $# -eq 0 ]; then\nJS_NAME=\"${CRATE_NAME}\"\nelse\nJS_NAME=\"${1}\"\nfi\n\n# Default to a dev build\nWASM_PACK_FLAGS=\"${WASM_PACK_FLAGS:-\"--dev\"}\"\n\nif [ $CRATE_NAME == widgetry_demo ]; then\n\tcd $PROJECT_ROOT/$CRATE_NAME\nelse\n\tcd $PROJECT_ROOT/apps/$CRATE_NAME\nfi\nwasm-pack build $WASM_PACK_FLAGS --target web --out-dir \"${PROJECT_ROOT}/web/src/${JS_NAME}/wasm_pkg\" -- --no-default-features --features wasm\n\n\n# web/Makefile:\nDEFAULT: dev\n\nSERVER_PORT=8000\nREPO_ROOT:=$(shell git rev-parse --show-toplevel)\n\n##\n# Section: Tasks (Phony targets)\n##\n\nAPPS=abstreet fifteen_min osm_viewer santa widgetry_demo map_editor ltn\n\n.PHONY: server clean dev release $(APPS)\n.PRECIOUS: src/%/wasm_pkg\n\nTSC=npx tsc --lib dom,es2020 --module es2020 --target es6 --strict --noEmitOnError --outDir build\n\nclean:\n\trm -fr build\n\trm -fr src/*/wasm_pkg\n\n# Build all apps for distribution (optimized)\n# This assume's you'll upload any required data to the web-root separately.\nrelease: export WASM_PACK_FLAGS=--release\n# note: `clean` is because we don't know if any cached wasm files were optimized\n# Once you've compiled the optimized wasm this way, you can skip `clean` and just run `make build`, since the remaining output is identical for dev vs release\nrelease: clean build\n\n# Build all apps for local dev, and symlink the data dir into the web-root.\ndev: export WASM_PACK_FLAGS=--dev\ndev: build build/dist/data\n\nserver: build/dist/data\n\tcd build/dist && python3 -m http.server $(SERVER_PORT)\n\n##\n# Section: Shared Deps and Templates\n##\n\n# Build all of our apps\nbuild: $(APPS) build/dist/index.html\n\n# Symlink in data for dev builds\nbuild/dist/data:\n\tln -sf ../../../data build/dist/data\n\nbuild/dist/%.html: src/web_root/*.html\n\t# just copy everything... we could do something more nuanced\n\tcp -r src/web_root/* build/dist\n\n# We rebuild wasm when any of these files change. \n#\n# Because Make doesn't know about rust's build system, it's pretty naive:\n# changing any rust file in any crate will trigger rebuilding the wasm \n# (the rebuilds themselves should be pretty fast due to incremental compilation)\nRUST_SOURCES=$(shell find ../ -name \\*.rs)\n\n# Produce the wasm package via our wasm-pack script\nsrc/%/wasm_pkg: $(RUST_SOURCES)\n\tbin/build-wasm $*\n\ttouch $@\n\n# simply copies over the wasm pkg we \n# built to be able to compile our typescript\nbuild/dist/%/wasm_pkg: src/%/wasm_pkg\n\tmkdir -p $(dir $@)\n\tcp -r \"${<}\" $(dir $@)\n\n# Concatenate the target crate's js file with the generic widgetry loading\n# code.\n#\n# Alternatives and their downsides would be:\n#  1. import outside of pkg root\n#  \t - pkg is less portable\n#  2. copy widgetry.js file into each package and update import path on build\n#  \t - not really any less hacky, since we're still transforming at build\n#  \t - an extra request for the client\n#  3. use proper bundler like webpack and system.js:\n#  \t - They're all complex - conceptually and dependency-wise\n#  \t - We can't use AMD modules because it doesn't support `import.meta`\nbuild/dist/%.bundle.js: build/widgetry.js build/%.js\n\tmkdir -p $(dir $@)\n\tbin/bundle-widgetry-js $^ > $@\n\nbuild/%.js: src/%.ts\n\t$(TSC) $^\n\n##\n# Section: Apps\n##\n\n## A/BStreet\n\nabstreet: build/dist/abstreet/wasm_pkg build/dist/abstreet/abstreet.bundle.js build/dist/abstreet build/dist/abstreet.html\n\n# Unlike the other crates, we have an explicit rule to give the \"game\" js a\n# more meaningful name\nsrc/abstreet/wasm_pkg: $(RUST_SOURCES)\n\tbin/build-wasm game abstreet\n\ttouch src/abstreet/wasm_pkg\n\nbuild/dist/abstreet/abstreet.bundle.js: build/widgetry.js build/abstreet/abstreet.js\n\n## Fifteen Minute Tool\n\nfifteen_min: build/dist/fifteen_min/wasm_pkg build/dist/fifteen_min/fifteen_min.bundle.js build/dist/fifteen_min.html\n\nbuild/dist/fifteen_min/fifteen_min.bundle.js: build/widgetry.js build/fifteen_min/fifteen_min.js\n\n## OSM Viewer\n\nosm_viewer: build/dist/osm_viewer/wasm_pkg build/dist/osm_viewer/osm_viewer.bundle.js build/dist/osm_viewer.html\n\nbuild/dist/osm_viewer/osm_viewer.bundle.js: build/widgetry.js build/osm_viewer/osm_viewer.js\n\n## Widgetry Demo\n\nwidgetry_demo: build/dist/widgetry_demo/wasm_pkg build/dist/widgetry_demo/widgetry_demo.bundle.js build/dist/widgetry_demo.html\n\nbuild/dist/widgetry_demo/widgetry_demo.bundle.js: build/widgetry.js build/widgetry_demo/widgetry_demo.js\n\n## Santa\n\nsanta: build/dist/santa/wasm_pkg build/dist/santa/santa.bundle.js build/dist/santa.html\n\nbuild/dist/santa/santa.bundle.js: build/widgetry.js build/santa/santa.js\n\n## RawMap editor\n\nmap_editor: build/dist/map_editor/wasm_pkg build/dist/map_editor/map_editor.bundle.js build/dist/map_editor.html\n\nbuild/dist/map_editor/map_editor.bundle.js: build/widgetry.js build/map_editor/map_editor.js\n\n## LTN\n\nltn: build/dist/ltn/wasm_pkg build/dist/ltn/ltn.bundle.js build/dist/ltn.html\n\nbuild/dist/ltn/ltn.bundle.js: build/widgetry.js build/ltn/ltn.js\n\n\n# web/package-lock.json:\n{\n  \"name\": \"widgetry-apps\",\n  \"version\": \"0.1.0\",\n  \"lockfileVersion\": 2,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"widgetry-apps\",\n      \"version\": \"0.1.0\",\n      \"devDependencies\": {\n        \"prettier\": \"^2.2.1\",\n        \"typescript\": \"^4.2.3\"\n      }\n    },\n    \"node_modules/prettier\": {\n      \"version\": \"2.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/prettier/-/prettier-2.2.1.tgz\",\n      \"integrity\": \"sha512-PqyhM2yCjg/oKkFPtTGUojv7gnZAoG80ttl45O6x2Ug/rMJw4wcc9k6aaf2hibP7BGVCCM33gZoGjyvt9mm16Q==\",\n      \"dev\": true,\n      \"bin\": {\n        \"prettier\": \"bin-prettier.js\"\n      },\n      \"engines\": {\n        \"node\": \">=10.13.0\"\n      }\n    },\n    \"node_modules/typescript\": {\n      \"version\": \"4.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-4.2.3.tgz\",\n      \"integrity\": \"sha512-qOcYwxaByStAWrBf4x0fibwZvMRG+r4cQoTjbPtUlrWjBHbmCAww1i448U0GJ+3cNNEtebDteo/cHOR3xJ4wEw==\",\n      \"dev\": true,\n      \"bin\": {\n        \"tsc\": \"bin/tsc\",\n        \"tsserver\": \"bin/tsserver\"\n      },\n      \"engines\": {\n        \"node\": \">=4.2.0\"\n      }\n    }\n  },\n  \"dependencies\": {\n    \"prettier\": {\n      \"version\": \"2.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/prettier/-/prettier-2.2.1.tgz\",\n      \"integrity\": \"sha512-PqyhM2yCjg/oKkFPtTGUojv7gnZAoG80ttl45O6x2Ug/rMJw4wcc9k6aaf2hibP7BGVCCM33gZoGjyvt9mm16Q==\",\n      \"dev\": true\n    },\n    \"typescript\": {\n      \"version\": \"4.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-4.2.3.tgz\",\n      \"integrity\": \"sha512-qOcYwxaByStAWrBf4x0fibwZvMRG+r4cQoTjbPtUlrWjBHbmCAww1i448U0GJ+3cNNEtebDteo/cHOR3xJ4wEw==\",\n      \"dev\": true\n    }\n  }\n}\n\n\n# web/package.json:\n{\n  \"author\": \"Michael Kirk<michael.code@endoftheworl.de\",\n  \"name\": \"widgetry-apps\",\n  \"version\": \"0.1.0\",\n  \"scripts\": {\n    \"fmt\": \"prettier --write src\"\n  },\n  \"devDependencies\": {\n    \"prettier\": \"^2.2.1\",\n    \"typescript\": \"^4.2.3\"\n  }\n}\n\n\n# web/src/widgetry.ts:\n// WidgetryApp is a wrapper for a rust Widgetry app which has been compiled to a wasm package using wasm_bindgen.\n//\n// The type signatures of `InitInput` and `initializeWasm` were copy/pasted from the wasm_bindgen\n// generated ts.d files. They should be stable, unless wasm_bindgen has breaking changes.\nexport type InitInput =\n  | RequestInfo\n  | URL\n  | Response\n  | BufferSource\n  | WebAssembly.Module;\n\nexport abstract class WidgetryApp<InitOutput> {\n  private appLoader: AppLoader<InitOutput>;\n  private _assetsBaseURL: string;\n  private _assetsAreGzipped: boolean;\n\n  public constructor(domId: string) {\n    this.appLoader = new AppLoader(this, domId);\n\n    // Assume a default relative path to where we can find the \"system\" dir\n    // Override with `myApp.setAssetsBaseURL('path/to/dir')`\n    this._assetsBaseURL = \"./data\";\n\n    // Assume files are gzipped unless on localhost.\n    // Override with `myApp.setAssetsAreGzipped(true)`\n    this._assetsAreGzipped = !isLocalhost;\n  }\n\n  public async loadAndStart() {\n    this.appLoader.loadAndStart();\n  }\n\n  // Assets (the \"system\" dir) are assumed to be at \"./data\" relative\n  // to the current URL. Otherwise override with `setAssetsBaseURL`.\n  public assetsBaseURL(): string {\n    return this._assetsBaseURL;\n  }\n\n  public setAssetsBaseURL(newValue: string) {\n    this._assetsBaseURL = newValue;\n  }\n\n  // Assets are assumed to gzipped, unless on localhost\n  public assetsAreGzipped(): boolean {\n    return this._assetsAreGzipped;\n  }\n\n  public setAssetsAreGzipped(newValue: boolean) {\n    this._assetsAreGzipped = newValue;\n  }\n\n  abstract initializeWasm(\n    module_or_path?: InitInput | Promise<InitInput>\n  ): Promise<InitOutput>;\n  abstract run(\n    rootDomId: string,\n    assetsBaseURL: string,\n    assetsAreGzipped: boolean\n  ): void;\n  abstract wasmURL(): string;\n}\n\nenum LoadState {\n  unloaded,\n  loading,\n  loaded,\n  starting,\n  started,\n  error,\n}\n\n/**\n * Helper class used by `WidgetryApp` implementations to load their wasm and\n * render their content.\n */\nexport class AppLoader<T> {\n  app: WidgetryApp<T>;\n  el: HTMLElement;\n  loadingEl?: HTMLElement;\n  errorEl?: HTMLElement;\n  domId: string;\n  state: LoadState = LoadState.unloaded;\n  // (receivedLength, totalLength)\n  downloadProgress?: [number, number];\n  errorMessage?: string;\n\n  public constructor(app: WidgetryApp<T>, domId: string) {\n    this.app = app;\n    this.domId = domId;\n    const el = document.getElementById(domId);\n    if (el === null) {\n      throw new Error(`element with domId: ${domId} not found`);\n    }\n    this.el = el;\n    console.log(\"sim constructor\", this);\n  }\n\n  public async loadAndStart() {\n    this.render();\n    try {\n      await this.load();\n      await this.start();\n    } catch (e) {\n      this.reportErrorState(e.toString());\n      throw e;\n    }\n  }\n\n  async load() {\n    console.assert(this.state == LoadState.unloaded, \"already loaded\");\n    this.updateState(LoadState.loading);\n\n    console.log(\"Started loading WASM\");\n    const t0 = performance.now();\n    let response: Response = await fetch(this.app.wasmURL());\n\n    if (response.body == null) {\n      this.reportErrorState(\"response.body was unexpectedly null\");\n      return;\n    }\n    let reader = response.body.getReader();\n\n    let contentLength = response.headers.get(\"Content-Length\");\n    if (contentLength == undefined) {\n      this.reportErrorState(\n        \"unable to fetch wasm - contentLength was unexpectedly undefined\"\n      );\n      return;\n    }\n\n    if (response.status == 404) {\n      this.reportErrorState(\n        `server misconfiguration, wasm file not found: ${this.app.wasmURL()}`\n      );\n      return;\n    }\n\n    this.downloadProgress = [0, parseInt(contentLength)];\n\n    let chunks: Uint8Array[] = [];\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        break;\n      }\n      if (value == undefined) {\n        console.error(\"reader value was unexpectedly undefined\");\n        break;\n      }\n      chunks.push(value);\n      this.downloadProgress[0] += value.length;\n      this.render();\n    }\n    let blob = new Blob(chunks);\n    let buffer = await blob.arrayBuffer();\n    const t1 = performance.now();\n    console.log(`It took ${t1 - t0} ms to download WASM, now initializing it`);\n\n    // TODO: Prefer streaming instantiation where available (not safari)? Seems like it'd be faster.\n    // const { instance } = await WebAssembly.instantiateStreaming(response, imports);\n\n    //let imports = {};\n    //let instance = await WebAssembly.instantiate(bytes, imports);\n\n    await this.app.initializeWasm(buffer);\n    this.updateState(LoadState.loaded);\n  }\n\n  async start() {\n    console.assert(this.state == LoadState.loaded, \"not yet loaded\");\n    this.updateState(LoadState.starting);\n    try {\n      console.log(\n        `running app with assetsBaseURL: ${this.app.assetsBaseURL()}, assetsAreGzipped: ${this.app.assetsAreGzipped()}`\n      );\n      this.app.run(\n        this.domId,\n        this.app.assetsBaseURL(),\n        this.app.assetsAreGzipped()\n      );\n    } catch (e) {\n      if (\n        e.toString() ==\n        \"Error: Using exceptions for control flow, don't mind me. This isn't actually an error!\"\n      ) {\n        // This is an expected, albeit unfortunate, control flow mechanism for winit on wasm.\n        this.updateState(LoadState.started);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  isWebGL1Supported(): boolean {\n    try {\n      var canvas = document.createElement(\"canvas\");\n      return !!canvas.getContext(\"webgl\");\n    } catch (e) {\n      return false;\n    }\n  }\n\n  isWebGL2Supported(): boolean {\n    try {\n      var canvas = document.createElement(\"canvas\");\n      return !!canvas.getContext(\"webgl2\");\n    } catch (e) {\n      return false;\n    }\n  }\n\n  updateState(newValue: LoadState) {\n    console.debug(\n      `state change: ${LoadState[this.state]} -> ${LoadState[newValue]}`\n    );\n    this.state = newValue;\n    this.render();\n  }\n\n  reportErrorState(errorMessage: string) {\n    this.errorMessage = errorMessage;\n    this.updateState(LoadState.error);\n  }\n\n  // UI\n\n  render() {\n    this.el.style.backgroundColor = \"black\";\n\n    switch (this.state) {\n      case LoadState.loading: {\n        if (this.loadingEl == undefined) {\n          this.loadingEl = buildLoadingEl();\n          // insert after rendering initial progress to avoid jitter.\n          this.el.append(this.loadingEl);\n        }\n\n        if (this.downloadProgress != undefined) {\n          let received = this.downloadProgress[0];\n          let total = this.downloadProgress[1];\n          let progressText = `${prettyPrintBytes(\n            received\n          )} / ${prettyPrintBytes(total)}`;\n          let percentText = `${(100.0 * received) / total}%`;\n          this.loadingEl.querySelector<HTMLElement>(\n            \".widgetry-app-loader-progress-text\"\n          )!.innerText = progressText;\n          this.loadingEl.querySelector<HTMLElement>(\n            \".widgetry-app-loader-progress-bar\"\n          )!.style.width = percentText;\n        }\n\n        break;\n      }\n      case LoadState.error: {\n        if (this.loadingEl != undefined) {\n          this.loadingEl.remove();\n          this.loadingEl = undefined;\n        }\n\n        if (this.errorEl == undefined) {\n          if (!this.isWebGL1Supported() && !this.isWebGL2Supported()) {\n            this.errorMessage =\n              this.errorMessage +\n              \"\ud83d\ude2d Looks like your browser doesn't support WebGL.\";\n          }\n\n          if (this.errorMessage == undefined) {\n            this.errorMessage =\n              \"An unknown error occurred. Try checking the developer console.\";\n          }\n\n          let el = buildErrorEl(this.errorMessage);\n          this.errorEl = el;\n          this.el.append(el);\n        }\n\n        break;\n      }\n    }\n  }\n}\n\nexport function modRoot(importMetaURL: string): string {\n  function dirname(path: string): string {\n    return path.match(/.*\\//)!.toString();\n  }\n\n  let url = new URL(importMetaURL);\n  url.pathname = dirname(url.pathname).toString();\n  return url.toString();\n}\n\nfunction buildLoadingEl(): HTMLElement {\n  let loadingEl = document.createElement(\"div\");\n  loadingEl.innerHTML = `\n        <style type=\"text/css\">\n            .widgetry-app-loader {\n                color: white;\n                padding: 16px;\n            }\n            .widgetry-app-loader-progress-bar-container {\n                background-color: black;\n                border: 1px solid white;\n                border-radius: 4px;\n            }\n            .widgetry-app-loader-progress-bar {\n                background-color: white; \n                height: 12px;\n            }\n            .widgetry-app-loader-progress-text {\n                margin-bottom: 16px;\n            }\n        </style>\n        <p><strong>Loading...</strong></p>\n        <div class=\"widgetry-app-loader-progress-bar-container\" style=\"width: 100%;\">\n            <div class=\"widgetry-app-loader-progress-bar\" style=\"width: 1%;\"></div>\n        </div>\n        <div class=\"widgetry-app-loader-progress-text\">0 / 0</div>\n        <p>If you think something has broken, check your browser's developer console (Ctrl+Shift+I or similar)</p>\n        <p>(Your browser must support WebGL and WebAssembly)</p>\n    `;\n  loadingEl.setAttribute(\"class\", \"widgetry-app-loader\");\n\n  return loadingEl;\n}\n\nfunction buildErrorEl(errorMessage: string): HTMLElement {\n  let el = document.createElement(\"p\");\n  el.innerHTML = `\n      <style type=\"text/css\">\n        .widgetry-app-loader-error {\n          color: white;\n          text-align: center;\n          padding: 16px;\n        }\n      </style>\n      <h2>Error Loading App</h2>\n      ${errorMessage}\n    `;\n  el.setAttribute(\"class\", \"widgetry-app-loader-error\");\n\n  return el;\n}\n\nfunction prettyPrintBytes(bytes: number): string {\n  if (bytes < 1024 ** 2) {\n    return Math.round(bytes / 1024) + \" KB\";\n  }\n  return Math.round(bytes / 1024 ** 2) + \" MB\";\n}\n\n// courtesy: https://stackoverflow.com/a/57949518\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    window.location.hostname === \"0.0.0.0\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\n\n# raw_map/Cargo.toml:\n[package]\nname = \"raw_map\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\ngeom = { workspace = true }\nserde = { workspace = true, features=[\"derive\"] }\nosm2streets = { git = \"https://github.com/a-b-street/osm2streets\" }\npopgetter = { path = \"../popgetter\" }\nstrum = \"0.24.1\"\nstrum_macros = \"0.24.3\"\n\n\n# convert_osm/Cargo.toml:\n[package]\nname = \"convert_osm\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\ncsv = { workspace = true }\nelevation = { git = \"https://github.com/dabreegster/elevation\" }\nfs-err = { workspace = true }\ngeom = { workspace = true }\nkml = { path = \"../kml\" }\nlog = { workspace = true }\nosm2streets = { git = \"https://github.com/a-b-street/osm2streets\" }\npopgetter = { path = \"../popgetter\" }\nraw_map = { path = \"../raw_map\" }\nserde = { workspace = true, features=[\"derive\"] }\nstreets_reader = { git = \"https://github.com/a-b-street/osm2streets\" }\n\n\n# convert_osm/src/lib.rs:\n#[macro_use]\nextern crate log;\n\nuse std::collections::{HashMap, HashSet};\n\nuse anyhow::Result;\n\nuse abstio::MapName;\nuse abstutil::{Tags, Timer};\nuse geom::{Distance, HashablePt2D, LonLat, PolyLine, Polygon};\nuse osm2streets::{osm, MapConfig, Road, RoadID};\nuse raw_map::{CrossingType, ExtraRoadData, RawMap};\n\nmod elevation;\nmod extract;\nmod gtfs;\nmod parking;\n\n/// Configures the creation of a `RawMap` from OSM and other input data.\npub struct Options {\n    pub map_config: MapConfig,\n\n    pub onstreet_parking: OnstreetParking,\n    pub public_offstreet_parking: PublicOffstreetParking,\n    pub private_offstreet_parking: PrivateOffstreetParking,\n    /// If provided, read polygons from this GeoJSON file and add them to the RawMap as buildings.\n    pub extra_buildings: Option<String>,\n    /// Configure public transit using this URL to a static GTFS feed in .zip format.\n    pub gtfs_url: Option<String>,\n    /// Path to a GeoTIFF file in EPSG:4326 to use for elevation data\n    pub elevation_geotiff: Option<String>,\n    /// Only include crosswalks that match a `highway=crossing` OSM node.\n    pub filter_crosswalks: bool,\n}\n\nimpl Options {\n    pub fn default() -> Self {\n        Self {\n            map_config: MapConfig::default(),\n            onstreet_parking: OnstreetParking::JustOSM,\n            public_offstreet_parking: PublicOffstreetParking::None,\n            private_offstreet_parking: PrivateOffstreetParking::FixedPerBldg(1),\n            extra_buildings: None,\n            gtfs_url: None,\n            elevation_geotiff: None,\n            filter_crosswalks: false,\n        }\n    }\n}\n\n/// What roads will have on-street parking lanes? Data from\n/// <https://wiki.openstreetmap.org/wiki/Key:parking:lane> is always used if available.\npub enum OnstreetParking {\n    /// If not tagged, there won't be parking.\n    JustOSM,\n    /// If OSM data is missing, then try to match data from\n    /// <http://data-seattlecitygis.opendata.arcgis.com/datasets/blockface>. This is Seattle specific.\n    Blockface(String),\n}\n\n/// How many spots are available in public parking garages?\npub enum PublicOffstreetParking {\n    None,\n    /// Pull data from\n    /// <https://data-seattlecitygis.opendata.arcgis.com/datasets/public-garages-or-parking-lots>, a\n    /// Seattle-specific data source.\n    Gis(String),\n}\n\n/// If a building doesn't have anything from public_offstreet_parking and isn't tagged as a garage\n/// in OSM, how many private spots should it have?\npub enum PrivateOffstreetParking {\n    FixedPerBldg(usize),\n    // TODO Based on the number of residents?\n}\n\n/// Create a RawMap from OSM and other input data.\npub fn convert(\n    osm_input_path: String,\n    name: MapName,\n    clip_path: Option<String>,\n    opts: Options,\n    timer: &mut Timer,\n) -> RawMap {\n    timer.start(\"create RawMap from input data\");\n\n    let mut map = RawMap::blank(name);\n    // Note that DrivingSide is still incorrect. It'll be set in extract_osm, before Road::new\n    // happens in split_ways.\n    map.streets.config = opts.map_config.clone();\n\n    let clip_pts = clip_path.map(|path| LonLat::read_geojson_polygon(&path).unwrap());\n    timer.start(\"extract all from OSM\");\n    let extract = extract::extract_osm(&mut map, &osm_input_path, clip_pts, &opts, timer);\n    timer.stop(\"extract all from OSM\");\n    let pt_to_road =\n        streets_reader::split_ways::split_up_roads(&mut map.streets, extract.osm, timer);\n\n    // Cul-de-sacs aren't supported yet.\n    map.streets.retain_roads(|r| r.src_i != r.dst_i);\n\n    map.bus_routes_on_roads = extract.bus_routes_on_roads;\n    map.extra_pois = extract.extra_pois;\n\n    clip_map(&mut map, timer);\n\n    for i in map.streets.intersections.keys() {\n        map.elevation_per_intersection.insert(*i, Distance::ZERO);\n    }\n    for r in map.streets.roads.keys() {\n        map.extra_road_data.insert(*r, ExtraRoadData::default());\n    }\n\n    // Remember OSM tags for all roads. Do this before apply_parking, which looks at tags\n    timer.start(\"preserve OSM tags\");\n    let mut way_ids = HashSet::new();\n    for r in map.streets.roads.values() {\n        for id in &r.osm_ids {\n            way_ids.insert(*id);\n        }\n    }\n    for (id, way) in extract.doc.ways {\n        if way_ids.contains(&id) {\n            map.osm_tags.insert(id, way.tags);\n        }\n    }\n    timer.stop(\"preserve OSM tags\");\n\n    parking::apply_parking(&mut map, &opts, timer);\n\n    timer.start(\"use barrier and crossing nodes\");\n    use_barrier_nodes(&mut map, extract.barrier_nodes, &pt_to_road);\n    use_crossing_nodes(&mut map, &extract.crossing_nodes, &pt_to_road);\n    timer.stop(\"use barrier and crossing nodes\");\n\n    if opts.filter_crosswalks {\n        filter_crosswalks(&mut map, extract.crossing_nodes, pt_to_road, timer);\n    }\n\n    if let Some(ref path) = opts.elevation_geotiff {\n        timer.start(\"add elevation data\");\n        if let Err(err) = elevation::add_data(&mut map, path, timer) {\n            error!(\"No elevation data: {}\", err);\n        }\n        timer.stop(\"add elevation data\");\n    }\n    if let Some(ref path) = opts.extra_buildings {\n        add_extra_buildings(&mut map, path).unwrap();\n    }\n\n    if opts.gtfs_url.is_some() {\n        gtfs::import(&mut map).unwrap();\n    }\n\n    timer.start(\"Add census data\");\n    if let Err(err) = add_census(&mut map) {\n        error!(\"Skipping census data: {err}\");\n    }\n    timer.stop(\"Add census data\");\n\n    if map.name == MapName::new(\"gb\", \"bristol\", \"east\") {\n        bristol_hack(&mut map);\n    }\n\n    timer.stop(\"create RawMap from input data\");\n\n    map\n}\n\nfn add_extra_buildings(map: &mut RawMap, path: &str) -> Result<()> {\n    let require_in_bounds = true;\n    let mut id = -1;\n    for (polygon, _) in Polygon::from_geojson_bytes(\n        &abstio::slurp_file(path)?,\n        &map.streets.gps_bounds,\n        require_in_bounds,\n    )? {\n        // Add these as new buildings, generating a new dummy OSM ID.\n        map.buildings.insert(\n            osm::OsmID::Way(osm::WayID(id)),\n            raw_map::RawBuilding {\n                polygon,\n                osm_tags: Tags::empty(),\n                public_garage_name: None,\n                num_parking_spots: 1,\n                amenities: Vec::new(),\n            },\n        );\n        // We could use new_osm_way_id, but faster to just assume we're the only place introducing\n        // new OSM IDs.\n        id -= -1;\n    }\n    Ok(())\n}\n\n// We're using Bristol for a project that requires an unusual LTN neighborhood boundary. Insert a\n// fake road where a bridge crosses another road, to force blockfinding to trace along there.\nfn bristol_hack(map: &mut RawMap) {\n    let mut tags = Tags::empty();\n    tags.insert(\"highway\", \"service\");\n    tags.insert(\"name\", \"Fake road\");\n    tags.insert(\"oneway\", \"yes\");\n    tags.insert(\"sidewalk\", \"none\");\n    tags.insert(\"lanes\", \"1\");\n    // TODO The LTN pathfinding tool will try to use this road. Discourage that heavily. It'd be\n    // safer to mark this as under construction, but then blockfinding wouldn't treat it as a\n    // boundary.\n    tags.insert(\"maxspeed\", \"1 mph\");\n    tags.insert(\"bicycle\", \"no\");\n\n    let src_i = map\n        .streets\n        .intersections\n        .values()\n        .find(|i| i.osm_ids.contains(&osm::NodeID(364061012)))\n        .unwrap()\n        .id;\n    let dst_i = map\n        .streets\n        .intersections\n        .values()\n        .find(|i| i.osm_ids.contains(&osm::NodeID(1215755208)))\n        .unwrap()\n        .id;\n\n    let id = map.streets.next_road_id();\n    map.streets.insert_road(Road::new(\n        id,\n        Vec::new(),\n        src_i,\n        dst_i,\n        PolyLine::must_new(vec![\n            map.streets.intersections[&src_i].polygon.center(),\n            map.streets.intersections[&dst_i].polygon.center(),\n        ]),\n        tags,\n        &map.streets.config,\n    ));\n    map.extra_road_data.insert(id, ExtraRoadData::default());\n}\n\nfn clip_map(map: &mut RawMap, timer: &mut Timer) {\n    let boundary_polygon = map.streets.boundary_polygon.clone();\n\n    map.buildings = timer.retain_parallelized(\n        \"clip buildings to boundary\",\n        std::mem::take(&mut map.buildings),\n        |b| {\n            b.polygon\n                .get_outer_ring()\n                .points()\n                .iter()\n                .all(|pt| boundary_polygon.contains_pt(*pt))\n        },\n    );\n\n    map.areas = timer\n        .parallelize(\n            \"clip areas to boundary\",\n            std::mem::take(&mut map.areas),\n            |orig_area| {\n                let mut result = Vec::new();\n                // If clipping fails, giving up on some areas is fine\n                if let Ok(list) = map\n                    .streets\n                    .boundary_polygon\n                    .intersection(&orig_area.polygon)\n                {\n                    for polygon in list {\n                        let mut area = orig_area.clone();\n                        area.polygon = polygon;\n                        result.push(area);\n                    }\n                }\n                result\n            },\n        )\n        .into_iter()\n        .flatten()\n        .collect();\n\n    // TODO Don't touch parking lots. It'll be visually obvious if a clip intersects one of these.\n    // The boundary should be manually adjusted.\n}\n\nfn use_barrier_nodes(\n    map: &mut RawMap,\n    barrier_nodes: Vec<(osm::NodeID, HashablePt2D)>,\n    pt_to_road: &HashMap<HashablePt2D, RoadID>,\n) {\n    // An OSM node likely only maps to one intersection\n    let mut node_to_intersection = HashMap::new();\n    for i in map.streets.intersections.values() {\n        for node in &i.osm_ids {\n            node_to_intersection.insert(*node, i.id);\n        }\n    }\n\n    for (node, pt) in barrier_nodes {\n        // Many barriers are on footpaths or roads that we don't retain\n        if let Some(road) = pt_to_road.get(&pt).and_then(|r| map.streets.roads.get(r)) {\n            // Filters on roads that're already car-free are redundant\n            if road.is_driveable() {\n                map.extra_road_data\n                    .get_mut(&road.id)\n                    .unwrap()\n                    .barrier_nodes\n                    .push(pt.to_pt2d());\n            }\n        } else if let Some(i) = node_to_intersection.get(&node) {\n            let roads = &map.streets.intersections[i].roads;\n            if roads.len() == 2 {\n                // Arbitrarily put the barrier on one of the roads\n                map.extra_road_data\n                    .get_mut(&roads[0])\n                    .unwrap()\n                    .barrier_nodes\n                    .push(pt.to_pt2d());\n            } else {\n                // TODO Look for real examples at non-2-way intersections to understand what to do.\n                // If there's a barrier in the middle of a 4-way, does that disconnect all\n                // movements?\n                warn!(\n                    \"There's a barrier at {i}, but there are {} roads connected\",\n                    roads.len()\n                );\n            }\n        }\n    }\n}\n\nfn use_crossing_nodes(\n    map: &mut RawMap,\n    crossing_nodes: &HashSet<(HashablePt2D, CrossingType)>,\n    pt_to_road: &HashMap<HashablePt2D, RoadID>,\n) {\n    for (pt, kind) in crossing_nodes {\n        // Some crossings are on footpaths or roads that we don't retain\n        if let Some(road) = pt_to_road\n            .get(pt)\n            .and_then(|r| map.extra_road_data.get_mut(r))\n        {\n            road.crossing_nodes.push((pt.to_pt2d(), *kind));\n        }\n    }\n}\n\nfn filter_crosswalks(\n    map: &mut RawMap,\n    crosswalks: HashSet<(HashablePt2D, CrossingType)>,\n    pt_to_road: HashMap<HashablePt2D, RoadID>,\n    timer: &mut Timer,\n) {\n    // Normally we assume every road has a crosswalk, but since this map is configured to use OSM\n    // crossing nodes, let's reverse that assumption.\n    for road in map.extra_road_data.values_mut() {\n        road.crosswalk_forward = false;\n        road.crosswalk_backward = false;\n    }\n\n    // Match each crosswalk node to a road\n    timer.start_iter(\"filter crosswalks\", crosswalks.len());\n    for (pt, _) in crosswalks {\n        timer.next();\n        // Some crossing nodes are outside the map boundary or otherwise not on a road that we\n        // retained\n        if let Some(road) = pt_to_road.get(&pt).and_then(|r| map.streets.roads.get(r)) {\n            // Crossings aren't right at an intersection. Where is this point along the center\n            // line?\n            if let Some((dist, _)) = road.reference_line.dist_along_of_point(pt.to_pt2d()) {\n                let pct = dist / road.reference_line.length();\n                // Don't throw away any crossings. If it occurs in the first half of the road, snap\n                // to the first intersection. If there's a mid-block crossing mapped, that'll\n                // likely not be correctly interpreted, unless an intersection is there anyway.\n                let data = map.extra_road_data.get_mut(&road.id).unwrap();\n                if pct <= 0.5 {\n                    data.crosswalk_backward = true;\n                } else {\n                    data.crosswalk_forward = true;\n                }\n\n                // TODO Some crosswalks incorrectly snap to the intersection near a short service\n                // road, which later gets trimmed. So the crosswalk effectively disappears.\n            }\n        }\n    }\n}\n\nfn add_census(map: &mut RawMap) -> Result<()> {\n    // TODO Fixed to one area right now. Assumes the file exists.\n    if map.name.city.country != \"gb\" {\n        return Ok(());\n    }\n    let input_path = \"data/input/shared/popgetter/england.topojson\";\n    let boundary = map\n        .streets\n        .boundary_polygon\n        .to_geo_wgs84(&map.streets.gps_bounds);\n    for (geo_polygon, census_zone) in popgetter::clip_zones(input_path, boundary)? {\n        match Polygon::from_geo_wgs84(geo_polygon, &map.streets.gps_bounds) {\n            Ok(polygon) => {\n                map.census_zones.push((polygon, census_zone));\n            }\n            Err(err) => {\n                warn!(\"Skipping census zone {}: {}\", census_zone.id, err);\n            }\n        }\n    }\n    Ok(())\n}\n\n\n# tests/Cargo.toml:\n[package]\nname = \"tests\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\nblockfinding = { path = \"../blockfinding\" }\nconvert_osm = { path = \"../convert_osm\" }\nfs-err = { workspace = true }\ngeom = { workspace = true }\nmap_model = { path = \"../map_model\" }\nrand = { workspace = true }\nsim = { path = \"../sim\" }\nsynthpop = { path = \"../synthpop\" }\nltn = { path = \"../apps/ltn\" }\nprettydiff = \"0.6.4\"\n\n\n# tests/goldenfiles/ltn_proposals/edit_turn_restrictions.json:\n{\n  \"map_name\": {\n    \"city\": {\n      \"country\": \"zz\",\n      \"city\": \"oneshot\"\n    },\n    \"map\": \"turn_restriction_ltn_boundary\"\n  },\n  \"edits_name\": \"Untitled Proposal 1\",\n  \"version\": 13,\n  \"commands\": [\n    {\n      \"ChangeRoad\": {\n        \"r\": {\n          \"osm_way_id\": 688145941,\n          \"i1\": 2018986239,\n          \"i2\": 8250742348\n        },\n        \"new\": {\n          \"lanes_ltr\": [\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Fwd\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Fwd\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Back\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Back\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Biking\",\n              \"dir\": \"Fwd\",\n              \"width\": 15000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Biking\",\n              \"dir\": \"Back\",\n              \"width\": 15000,\n              \"allowed_turns\": 0\n            }\n          ],\n          \"speed_limit\": 134112,\n          \"access_restrictions\": {\n            \"allow_through_traffic\": 31\n          },\n          \"modal_filter\": null,\n          \"crossings\": [],\n          \"turn_restrictions\": [],\n          \"complicated_turn_restrictions\": []\n        },\n        \"old\": {\n          \"lanes_ltr\": [\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Fwd\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Fwd\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Back\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Back\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Biking\",\n              \"dir\": \"Fwd\",\n              \"width\": 15000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Biking\",\n              \"dir\": \"Back\",\n              \"width\": 15000,\n              \"allowed_turns\": 0\n            }\n          ],\n          \"speed_limit\": 134112,\n          \"access_restrictions\": {\n            \"allow_through_traffic\": 31\n          },\n          \"modal_filter\": null,\n          \"crossings\": [],\n          \"turn_restrictions\": [\n            [\n              \"BanTurns\",\n              4\n            ]\n          ],\n          \"complicated_turn_restrictions\": []\n        }\n      }\n    },\n    {\n      \"ChangeRoad\": {\n        \"r\": {\n          \"osm_way_id\": 688145941,\n          \"i1\": 2018986239,\n          \"i2\": 8250742348\n        },\n        \"new\": {\n          \"lanes_ltr\": [\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Fwd\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Fwd\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Back\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Back\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Biking\",\n              \"dir\": \"Fwd\",\n              \"width\": 15000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Biking\",\n              \"dir\": \"Back\",\n              \"width\": 15000,\n              \"allowed_turns\": 0\n            }\n          ],\n          \"speed_limit\": 134112,\n          \"access_restrictions\": {\n            \"allow_through_traffic\": 31\n          },\n          \"modal_filter\": null,\n          \"crossings\": [],\n          \"turn_restrictions\": [\n            [\n              \"BanTurns\",\n              12\n            ]\n          ],\n          \"complicated_turn_restrictions\": []\n        },\n        \"old\": {\n          \"lanes_ltr\": [\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Fwd\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Fwd\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Back\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Driving\",\n              \"dir\": \"Back\",\n              \"width\": 30000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Biking\",\n              \"dir\": \"Fwd\",\n              \"width\": 15000,\n              \"allowed_turns\": 0\n            },\n            {\n              \"lt\": \"Biking\",\n              \"dir\": \"Back\",\n              \"width\": 15000,\n              \"allowed_turns\": 0\n            }\n          ],\n          \"speed_limit\": 134112,\n          \"access_restrictions\": {\n            \"allow_through_traffic\": 31\n          },\n          \"modal_filter\": null,\n          \"crossings\": [],\n          \"turn_restrictions\": [],\n          \"complicated_turn_restrictions\": []\n        }\n      }\n    }\n  ],\n  \"proposal_description\": [],\n  \"proposal_link\": null\n}\n\n\n# map_gui/Cargo.toml:\n[package]\nname = \"map_gui\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[features]\nnative = [\"built\", \"subprocess\", \"widgetry/native-backend\"]\nwasm = [\"wasm-bindgen\", \"web-sys\", \"widgetry/wasm-backend\"]\n# A marker to use a named release from S3 instead of dev for updating files\nrelease_s3 = []\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\nbuilt = { version = \"0.7.1\", optional = true, features=[\"chrono\"] }\nchrono = \"0.4.31\"\ncolorous = { workspace = true }\ncontour = { workspace = true }\nflate2 = { workspace = true }\nfutures-channel = { workspace = true }\ngeojson = { workspace = true }\ngeom = { workspace = true }\ninstant = { workspace = true }\nlog = { workspace = true }\nlyon = \"1.0.1\"\nmap_model = { path = \"../map_model\" }\nregex = \"1.10.2\"\nrfd = \"0.11.3\"\nserde = { workspace = true, features=[\"derive\"] }\nsynthpop = { path = \"../synthpop\" }\nstructopt = { workspace = true }\nsubprocess = { git = \"https://github.com/hniksic/rust-subprocess\", optional = true }\nwasm-bindgen = { workspace = true, optional = true }\nweb-sys = { workspace = true, optional = true }\nwidgetry = { path = \"../widgetry\" }\nfs-err = { workspace = true }\n\n[build-dependencies]\nbuilt = { version = \"0.7.1\", features=[\"chrono\"] }\n\n\n# map_gui/src/lib.rs:\n//! This crate contains common code for applications that draw and interact with a `Map`.\n\n// Disable some noisy clippy warnings\n#![allow(clippy::too_many_arguments, clippy::type_complexity)]\n#![allow(clippy::new_without_default)]\n\n#[macro_use]\nextern crate anyhow;\n#[macro_use]\nextern crate log;\n\nuse abstutil::Timer;\nuse geom::{Duration, Pt2D, Time};\nuse map_model::{\n    AreaID, BuildingID, IntersectionID, LaneID, Map, ParkingLotID, RoadID, TransitStopID,\n};\nuse widgetry::{EventCtx, GfxCtx, State};\n\npub use self::simple_app::{SimpleApp, SimpleAppArgs};\nuse crate::render::DrawOptions;\nuse colors::{ColorScheme, ColorSchemeChoice};\nuse options::Options;\nuse render::DrawMap;\n\npub mod colors;\npub mod load;\npub mod options;\npub mod render;\nmod simple_app;\npub mod tools;\n\n/// An application wishing to use the tools in this crate has to implement this on the struct that\n/// implements `widgetry::SharedAppState`, so that the tools here can access the map. See\n/// `SimpleApp` for an example implementation.\npub trait AppLike {\n    fn map(&self) -> &Map;\n    fn cs(&self) -> &ColorScheme;\n    fn mut_cs(&mut self) -> &mut ColorScheme;\n    fn draw_map(&self) -> &DrawMap;\n    fn mut_draw_map(&mut self) -> &mut DrawMap;\n    fn opts(&self) -> &Options;\n    fn mut_opts(&mut self) -> &mut Options;\n    fn map_switched(&mut self, ctx: &mut EventCtx, map: Map, timer: &mut Timer);\n    fn draw_with_opts(&self, g: &mut GfxCtx, opts: DrawOptions);\n    /// Create a `widgetry::State` that warps to the given point.\n    fn make_warper(\n        &mut self,\n        ctx: &EventCtx,\n        pt: Pt2D,\n        target_cam_zoom: Option<f64>,\n        id: Option<ID>,\n    ) -> Box<dyn State<Self>>\n    where\n        Self: Sized;\n\n    // These two are needed to render traffic signals. They only make sense when there is a\n    // simulation\n    fn sim_time(&self) -> Time;\n    fn current_stage_and_remaining_time(&self, id: IntersectionID) -> (usize, Duration);\n\n    /// Change the color scheme. Idempotent. Return true if there was a change.\n    fn change_color_scheme(&mut self, ctx: &mut EventCtx, cs: ColorSchemeChoice) -> bool {\n        if self.opts().color_scheme == cs {\n            return false;\n        }\n        self.mut_opts().color_scheme = cs;\n        *self.mut_cs() = ColorScheme::new(ctx, self.opts().color_scheme);\n\n        ctx.loading_screen(\"rerendering map colors\", |ctx, timer| {\n            *self.mut_draw_map() = DrawMap::new(ctx, self.map(), self.opts(), self.cs(), timer);\n        });\n\n        true\n    }\n}\n\n#[derive(Clone, Hash, PartialEq, Eq, Debug, PartialOrd, Ord)]\npub enum ID {\n    Road(RoadID),\n    Lane(LaneID),\n    Intersection(IntersectionID),\n    Building(BuildingID),\n    ParkingLot(ParkingLotID),\n    TransitStop(TransitStopID),\n    Area(AreaID),\n}\n\n\n# map_gui/src/options.rs:\nuse serde::{Deserialize, Serialize};\n\nuse abstutil::Timer;\nuse geom::{Duration, UnitFmt};\nuse widgetry::{\n    CanvasSettings, Choice, EventCtx, GeomBatch, GfxCtx, Key, Line, Outcome, Panel, Spinner, State,\n    TextExt, Toggle, Widget,\n};\n\nuse crate::colors::ColorSchemeChoice;\nuse crate::render::DrawBuilding;\nuse crate::tools::grey_out_map;\nuse crate::AppLike;\n\n/// Options controlling the UI. Some of the options are common to all map-based apps, and some are\n/// specific to A/B Street.\n// TODO SimOptions stuff too\n#[derive(Clone, Serialize, Deserialize)]\npub struct Options {\n    /// Dev mode exposes experimental tools useful for debugging, but that'd likely confuse most\n    /// players.\n    pub dev: bool,\n    /// Every time we draw, render all agents zoomed in. Extremely slow. Just used to flush out\n    /// drawing bugs.\n    pub debug_all_agents: bool,\n\n    /// How traffic signals should be rendered.\n    pub traffic_signal_style: TrafficSignalStyle,\n    /// The color scheme for map elements, agents, and the UI.\n    pub color_scheme: ColorSchemeChoice,\n    /// Automatically change color_scheme based on simulation time to reflect day/night\n    pub toggle_day_night_colors: bool,\n    /// Draw buildings in different perspectives\n    pub camera_angle: CameraAngle,\n    /// Draw building driveways.\n    pub show_building_driveways: bool,\n    /// Draw building outlines.\n    pub show_building_outlines: bool,\n    /// Draw stop signs.\n    pub show_stop_signs: bool,\n    /// Draw crosswalks and unmarked crossings.\n    pub show_crosswalks: bool,\n    /// If true, draw an icon for traffic signals both when zoomed and unzoomed. If false, color\n    /// the intersection when unzoomed and render the signal's current state when zoomed.\n    pub show_traffic_signal_icon: bool,\n    /// If true, modify several basemap features to de-emphasize them: border intersections\n    pub simplify_basemap: bool,\n\n    /// When making a screen recording, enable this option to hide some UI elements\n    pub minimal_controls: bool,\n    /// widgetry options\n    pub canvas_settings: CanvasSettings,\n\n    /// How much to advance the sim with one of the speed controls\n    pub time_increment: Duration,\n    /// When time warping, don't draw to speed up simulation\n    pub dont_draw_time_warp: bool,\n    /// The delay threshold to halt on when jumping to the next delay\n    pub jump_to_delay: Duration,\n\n    /// Display roads and buildings in an alternate language, if possible. None means to use the\n    /// OSM native name.\n    pub language: Option<String>,\n    /// How to render geometric units\n    pub units: UnitFmt,\n}\n\nimpl Options {\n    /// Restore previous options. If the file is missing or the format has changed, fall back to\n    /// built-in defaults.\n    pub fn load_or_default() -> Options {\n        match abstio::maybe_read_json::<Options>(\n            abstio::path_player(\"settings.json\"),\n            &mut Timer::throwaway(),\n        ) {\n            Ok(opts) => {\n                return opts;\n            }\n            Err(err) => {\n                warn!(\"Couldn't restore settings, so using defaults. {}\", err);\n            }\n        }\n\n        Options {\n            dev: false,\n            debug_all_agents: false,\n\n            traffic_signal_style: TrafficSignalStyle::Brian,\n            color_scheme: ColorSchemeChoice::DayMode,\n            toggle_day_night_colors: false,\n            camera_angle: CameraAngle::TopDown,\n            show_building_driveways: true,\n            show_building_outlines: true,\n            show_stop_signs: true,\n            show_crosswalks: true,\n            show_traffic_signal_icon: false,\n            simplify_basemap: false,\n\n            time_increment: Duration::minutes(10),\n            dont_draw_time_warp: false,\n            jump_to_delay: Duration::minutes(5),\n\n            minimal_controls: false,\n            canvas_settings: CanvasSettings::new(),\n            language: None,\n            units: UnitFmt {\n                round_durations: true,\n                // TODO Should default be based on the map?\n                metric: false,\n            },\n        }\n    }\n}\n\n/// Different ways of drawing traffic signals. The names of these aren't super meaningful...\n#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]\npub enum TrafficSignalStyle {\n    Brian,\n    Yuwen,\n    IndividualTurnArrows,\n}\n\n#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]\npub enum CameraAngle {\n    TopDown,\n    IsometricNE,\n    IsometricNW,\n    IsometricSE,\n    IsometricSW,\n    Abstract,\n}\n\npub struct OptionsPanel {\n    panel: Panel,\n}\n\nimpl OptionsPanel {\n    pub fn new_state<A: AppLike>(ctx: &mut EventCtx, app: &A) -> Box<dyn State<A>> {\n        Box::new(OptionsPanel {\n            panel: Panel::new_builder(Widget::col(vec![\n                Widget::custom_row(vec![\n                    Line(\"Settings\").small_heading().into_widget(ctx),\n                    ctx.style().btn_close_widget(ctx),\n                ]),\n                \"Camera controls\".text_widget(ctx),\n                Widget::col(vec![\n                    Toggle::checkbox(\n                        ctx,\n                        \"Invert direction of vertical scrolling\",\n                        None,\n                        ctx.canvas.settings.invert_scroll,\n                    ),\n                    Toggle::checkbox(\n                        ctx,\n                        \"Pan map when cursor is at edge of screen\",\n                        None,\n                        ctx.canvas.settings.edge_auto_panning,\n                    )\n                    .named(\"autopan\"),\n                    Toggle::checkbox(\n                        ctx,\n                        \"Use touchpad to pan and hold Control to zoom\",\n                        None,\n                        ctx.canvas.settings.touchpad_to_move,\n                    ),\n                    Toggle::checkbox(\n                        ctx,\n                        \"Use arrow keys to pan and Q/W to zoom\",\n                        None,\n                        ctx.canvas.settings.keys_to_pan,\n                    ),\n                    Widget::row(vec![\n                        \"Scroll speed for menus\".text_widget(ctx).centered_vert(),\n                        Spinner::widget(\n                            ctx,\n                            \"gui_scroll_speed\",\n                            (1, 50),\n                            ctx.canvas.settings.gui_scroll_speed,\n                            1,\n                        ),\n                    ]),\n                    Widget::row(vec![\n                        \"Zoom speed for the map\".text_widget(ctx).centered_vert(),\n                        Spinner::widget(\n                            ctx,\n                            \"canvas_scroll_speed\",\n                            (1, 30),\n                            ctx.canvas.settings.canvas_scroll_speed,\n                            1,\n                        ),\n                    ]),\n                ])\n                .bg(app.cs().inner_panel_bg)\n                .padding(8),\n                \"Appearance\".text_widget(ctx),\n                Widget::col(vec![\n                    Widget::row(vec![\n                        \"Traffic signal rendering:\".text_widget(ctx),\n                        Widget::dropdown(\n                            ctx,\n                            \"Traffic signal rendering\",\n                            app.opts().traffic_signal_style.clone(),\n                            vec![\n                                Choice::new(\"Default (Brian's style)\", TrafficSignalStyle::Brian),\n                                Choice::new(\"Yuwen's style\", TrafficSignalStyle::Yuwen),\n                                Choice::new(\n                                    \"arrows showing individual turns (to debug)\",\n                                    TrafficSignalStyle::IndividualTurnArrows,\n                                ),\n                            ],\n                        ),\n                    ]),\n                    Widget::row(vec![\n                        \"Camera angle:\".text_widget(ctx),\n                        Widget::dropdown(\n                            ctx,\n                            \"Camera angle\",\n                            app.opts().camera_angle.clone(),\n                            vec![\n                                Choice::new(\"Top-down\", CameraAngle::TopDown),\n                                Choice::new(\"Isometric (northeast)\", CameraAngle::IsometricNE),\n                                Choice::new(\"Isometric (northwest)\", CameraAngle::IsometricNW),\n                                Choice::new(\"Isometric (southeast)\", CameraAngle::IsometricSE),\n                                Choice::new(\"Isometric (southwest)\", CameraAngle::IsometricSW),\n                                Choice::new(\"Abstract (just symbols)\", CameraAngle::Abstract),\n                            ],\n                        ),\n                    ]),\n                    Widget::row(vec![\n                        \"Color scheme:\".text_widget(ctx),\n                        Widget::dropdown(\n                            ctx,\n                            \"Color scheme\",\n                            app.opts().color_scheme,\n                            ColorSchemeChoice::choices(),\n                        ),\n                    ]),\n                    Widget::row(vec![\n                        \"Camera zoom to switch to unzoomed view\".text_widget(ctx),\n                        Widget::dropdown(\n                            ctx,\n                            \"min zoom\",\n                            ctx.canvas.settings.min_zoom_for_detail,\n                            vec![\n                                Choice::new(\"1.0\", 1.0),\n                                Choice::new(\"2.0\", 2.0),\n                                Choice::new(\"3.0\", 3.0),\n                                Choice::new(\"4.0\", 4.0),\n                                Choice::new(\"5.0\", 5.0),\n                                Choice::new(\"6.0\", 6.0),\n                            ],\n                        ),\n                    ]),\n                    Widget::row(vec![\"Language\".text_widget(ctx), {\n                        let mut default = app.opts().language.clone();\n                        let mut have_default = false;\n                        let mut choices = vec![Choice::new(\"Map native language\", None)];\n                        for lang in app.map().get_languages() {\n                            if default.as_ref() == Some(&lang) {\n                                have_default = true;\n                            }\n                            choices.push(Choice::new(lang.clone(), Some(lang)));\n                        }\n                        // We might be switching from a map that has more languages than this\n                        // map\n                        if !have_default {\n                            default = None;\n                        }\n                        Widget::dropdown(ctx, \"language\", default, choices)\n                    }]),\n                    Toggle::choice(\n                        ctx,\n                        \"metric / imperial units\",\n                        \"metric\",\n                        \"imperial\",\n                        None,\n                        app.opts().units.metric,\n                    ),\n                ])\n                .bg(app.cs().inner_panel_bg)\n                .padding(8),\n                \"Debug\".text_widget(ctx),\n                Widget::col(vec![\n                    Toggle::checkbox(ctx, \"Enable developer mode\", None, app.opts().dev),\n                    Toggle::checkbox(\n                        ctx,\n                        \"Draw all agents to debug geometry (Slow!)\",\n                        None,\n                        app.opts().debug_all_agents,\n                    ),\n                ])\n                .bg(app.cs().inner_panel_bg)\n                .padding(8),\n                ctx.style()\n                    .btn_solid_primary\n                    .text(\"Apply\")\n                    .hotkey(Key::Enter)\n                    .build_def(ctx)\n                    .centered_horiz(),\n            ]))\n            .build(ctx),\n        })\n    }\n}\n\nimpl<A: AppLike> State<A> for OptionsPanel {\n    fn event(&mut self, ctx: &mut EventCtx, app: &mut A) -> widgetry::Transition<A> {\n        if let Outcome::Clicked(x) = self.panel.event(ctx) {\n            match x.as_ref() {\n                \"close\" => {\n                    return widgetry::Transition::Pop;\n                }\n                \"Apply\" => {\n                    let mut opts = app.opts().clone();\n                    opts.dev = self.panel.is_checked(\"Enable developer mode\");\n                    opts.debug_all_agents = self\n                        .panel\n                        .is_checked(\"Draw all agents to debug geometry (Slow!)\");\n\n                    ctx.canvas.settings.invert_scroll = self\n                        .panel\n                        .is_checked(\"Invert direction of vertical scrolling\");\n                    ctx.canvas.settings.touchpad_to_move = self\n                        .panel\n                        .is_checked(\"Use touchpad to pan and hold Control to zoom\");\n                    ctx.canvas.settings.keys_to_pan = self\n                        .panel\n                        .is_checked(\"Use arrow keys to pan and Q/W to zoom\");\n                    ctx.canvas.settings.edge_auto_panning = self.panel.is_checked(\"autopan\");\n                    ctx.canvas.settings.gui_scroll_speed = self.panel.spinner(\"gui_scroll_speed\");\n                    ctx.canvas.settings.canvas_scroll_speed =\n                        self.panel.spinner(\"canvas_scroll_speed\");\n                    ctx.canvas.settings.min_zoom_for_detail = self.panel.dropdown_value(\"min zoom\");\n                    // Copy the settings into the Options struct, so they're saved.\n                    opts.canvas_settings = ctx.canvas.settings.clone();\n\n                    let style = self.panel.dropdown_value(\"Traffic signal rendering\");\n                    if opts.traffic_signal_style != style {\n                        opts.traffic_signal_style = style;\n                        println!(\"Rerendering traffic signals...\");\n                        for i in &mut app.mut_draw_map().intersections {\n                            *i.draw_traffic_signal.borrow_mut() = None;\n                        }\n                    }\n\n                    let camera_angle = self.panel.dropdown_value(\"Camera angle\");\n                    if opts.camera_angle != camera_angle {\n                        opts.camera_angle = camera_angle;\n                        ctx.loading_screen(\"rerendering buildings\", |ctx, timer| {\n                            let mut all_buildings = GeomBatch::new();\n                            let mut all_building_outlines = GeomBatch::new();\n                            timer\n                                .start_iter(\"rendering buildings\", app.map().all_buildings().len());\n                            for b in app.map().all_buildings() {\n                                timer.next();\n                                DrawBuilding::new(\n                                    ctx,\n                                    b,\n                                    app.map(),\n                                    app.cs(),\n                                    &opts,\n                                    &mut all_buildings,\n                                    &mut all_building_outlines,\n                                );\n                            }\n                            for r in &mut app.mut_draw_map().roads {\n                                r.clear_rendering();\n                            }\n\n                            timer.start(\"upload geometry\");\n                            app.mut_draw_map().draw_all_buildings = all_buildings.upload(ctx);\n                            app.mut_draw_map().draw_all_building_outlines =\n                                all_building_outlines.upload(ctx);\n                            timer.stop(\"upload geometry\");\n                        });\n                    }\n\n                    if app.change_color_scheme(ctx, self.panel.dropdown_value(\"Color scheme\")) {\n                        // change_color_scheme doesn't modify our local copy of Options!\n                        opts.color_scheme = app.opts().color_scheme;\n                        // If the player picks a different scheme, don't undo it later.\n                        opts.toggle_day_night_colors = false;\n                    }\n\n                    opts.units.metric = self.panel.is_checked(\"metric / imperial units\");\n\n                    let language = self.panel.dropdown_value(\"language\");\n                    if language != opts.language {\n                        opts.language = language;\n                        for r in &mut app.mut_draw_map().roads {\n                            r.clear_rendering();\n                        }\n                    }\n\n                    // Be careful -- there are some options not exposed by this panel, but per app.\n                    let show_building_driveways = opts.show_building_driveways;\n                    opts.show_building_driveways = true;\n                    let show_building_outlines = opts.show_building_outlines;\n                    opts.show_building_outlines = true;\n                    abstio::write_json(abstio::path_player(\"settings.json\"), &opts);\n                    opts.show_building_driveways = show_building_driveways;\n                    opts.show_building_outlines = show_building_outlines;\n                    *app.mut_opts() = opts;\n\n                    return widgetry::Transition::Pop;\n                }\n                _ => unreachable!(),\n            }\n        }\n\n        widgetry::Transition::Keep\n    }\n\n    fn draw(&self, g: &mut GfxCtx, app: &A) {\n        grey_out_map(g, app);\n        self.panel.draw(g);\n    }\n}\n\n\n# map_gui/src/colors.rs:\n//! A color scheme groups colors used for different map, dynamic, and UI elements in one place, to\n//! encourage deduplication. The player can also switch between different color schemes.\n\nuse std::io::Write;\n\nuse anyhow::Result;\nuse fs_err::File;\nuse serde::{Deserialize, Serialize};\n\nuse map_model::osm::RoadRank;\nuse map_model::{LaneType, Map};\nuse widgetry::tools::ColorScale;\nuse widgetry::{Choice, Color, EventCtx, Fill, Style, Texture};\n\nuse crate::tools::loading_tips;\n\n// I've gone back and forth how to organize color scheme code. I was previously against having one\n// centralized place with all definitions, because careful naming or comments are needed to explain\n// the context of a definition. That's unnecessary when the color is defined in the one place it's\n// used. But that was before we started consolidating the color palette in designs, and before we\n// started rapidly iterating on totally different schemes.\n//\n// For the record, the compiler catches typos with this approach, but I don't think I had a single\n// bug that took more than 30s to catch and fix in ~1.5 years of the untyped string key. ;)\n//\n// TODO There are plenty of colors left that aren't captured here. :(\n\n#[derive(Clone, Copy, PartialEq, Debug, Serialize, Deserialize)]\npub enum ColorSchemeChoice {\n    DayMode,\n    NightMode,\n    Textured,\n    ClassicDayMode,\n    LTN,\n}\n\nimpl ColorSchemeChoice {\n    pub fn choices() -> Vec<Choice<ColorSchemeChoice>> {\n        vec![\n            Choice::new(\"day mode\", ColorSchemeChoice::DayMode),\n            Choice::new(\"night mode\", ColorSchemeChoice::NightMode),\n            Choice::new(\"textured\", ColorSchemeChoice::Textured),\n            Choice::new(\"classic\", ColorSchemeChoice::ClassicDayMode),\n            Choice::new(\"LTN\", ColorSchemeChoice::LTN),\n        ]\n    }\n\n    pub fn parse(x: &str) -> Result<ColorSchemeChoice> {\n        let mut options = Vec::new();\n        for c in ColorSchemeChoice::choices() {\n            options.push(c.label.clone());\n            if c.label == x {\n                return Ok(c.data);\n            }\n        }\n        bail!(\n            \"Invalid --color_scheme={}. Choices: {}\",\n            x,\n            options.join(\", \")\n        );\n    }\n}\n\npub struct ColorScheme {\n    scheme: ColorSchemeChoice,\n\n    pub road_outlines: bool,\n    pub road_class_colors: bool,\n    pub show_buildings_in_minimap: bool,\n\n    // UI\n    pub panel_bg: Color,\n    pub inner_panel_bg: Color,\n    pub day_time_slider: Color,\n    pub night_time_slider: Color,\n    pub selected: Color,\n    pub current_object: Color,\n    pub perma_selected_object: Color,\n    pub fade_map_dark: Color,\n    gui_style: Style,\n    pub minimap_cursor_border: Color,\n    pub minimap_cursor_bg: Option<Color>,\n\n    // Roads\n    driving_lane: Color,\n    bus_lane: Color,\n    parking_lane: Color,\n    bike_lane: Color,\n    sidewalk: Color,\n    pub sidewalk_lines: Color,\n    pub general_road_marking: Color,\n    road_center_line: Color,\n    pub light_rail_track: Color,\n    pub private_road: Option<Color>,\n    pub unzoomed_highway: Color,\n    pub unzoomed_arterial: Color,\n    pub unzoomed_residential: Color,\n    pub unzoomed_cycleway: Color,\n    pub unzoomed_footway: Color,\n    footway: Color,\n    shared_use: Color,\n\n    // Intersections\n    pub normal_intersection: Color,\n    pub stop_sign: Color,\n    pub stop_sign_pole: Color,\n    pub signal_protected_turn: Color,\n    pub signal_permitted_turn: Color,\n    pub signal_banned_turn: Color,\n    pub signal_box: Color,\n    pub signal_spinner: Color,\n    pub signal_turn_block_bg: Color,\n\n    // Problems encountered on a trip\n    pub slowest_intersection: Color,\n    pub slower_intersection: Color,\n    pub slow_intersection: Color,\n\n    // Other static elements\n    pub void_background: Color,\n    pub map_background: Fill,\n    pub unzoomed_interesting_intersection: Color,\n    pub residential_building: Color,\n    pub commercial_building: Color,\n    pub building_outline: Color,\n    pub parking_lot: Color,\n    pub grass: Fill,\n    pub water: Fill,\n    pub study_area: Fill,\n\n    // Unzoomed dynamic elements\n    pub unzoomed_car: Color,\n    pub unzoomed_bike: Color,\n    pub unzoomed_bus: Color,\n    pub unzoomed_pedestrian: Color,\n\n    // Agents\n    agent_colors: Vec<Color>,\n    pub route: Color,\n    pub turn_arrow: Color,\n    pub brake_light: Color,\n    pub bus_body: Color,\n    pub bus_label: Color,\n    pub train_body: Color,\n    pub ped_head: Color,\n    pub ped_foot: Color,\n    pub ped_preparing_bike_body: Color,\n    pub ped_crowd: Color,\n    pub bike_frame: Color,\n    pub parked_car: Color,\n\n    // Layers\n    pub good_to_bad_red: ColorScale,\n    pub good_to_bad_green: ColorScale,\n    pub bus_layer: Color,\n    pub edits_layer: Color,\n\n    // Misc\n    pub parking_trip: Color,\n    pub bike_trip: Color,\n    pub bus_trip: Color,\n    pub before_changes: Color,\n    pub after_changes: Color,\n}\n\nimpl ColorScheme {\n    pub fn new(ctx: &mut EventCtx, scheme: ColorSchemeChoice) -> ColorScheme {\n        let mut cs = match scheme {\n            ColorSchemeChoice::DayMode => ColorScheme::day_mode(),\n            ColorSchemeChoice::NightMode => ColorScheme::night_mode(),\n            ColorSchemeChoice::Textured => ColorScheme::textured(),\n            ColorSchemeChoice::ClassicDayMode => ColorScheme::classic(),\n            ColorSchemeChoice::LTN => ColorScheme::ltn(),\n        };\n        cs.scheme = scheme;\n        ctx.set_style(cs.gui_style.clone());\n        cs\n    }\n\n    fn classic() -> ColorScheme {\n        let mut cs = Self::light_background(Style::light_bg());\n        cs.scheme = ColorSchemeChoice::ClassicDayMode;\n        cs\n    }\n\n    fn light_background(mut gui_style: Style) -> ColorScheme {\n        gui_style.loading_tips = loading_tips();\n        ColorScheme {\n            scheme: ColorSchemeChoice::DayMode,\n\n            road_outlines: false,\n            road_class_colors: false,\n            show_buildings_in_minimap: true,\n\n            // UI\n            panel_bg: gui_style.panel_bg,\n            inner_panel_bg: gui_style.section_bg,\n            day_time_slider: hex(\"#F4DA22\"),\n            night_time_slider: hex(\"#12409D\"),\n            selected: Color::RED.alpha(0.7),\n            current_object: Color::WHITE,\n            perma_selected_object: Color::BLUE,\n            fade_map_dark: Color::BLACK.alpha(0.6),\n            minimap_cursor_border: Color::BLACK,\n            minimap_cursor_bg: None,\n            gui_style,\n\n            // Roads\n            driving_lane: Color::BLACK,\n            bus_lane: Color::rgb(190, 74, 76),\n            parking_lane: Color::grey(0.2),\n            bike_lane: Color::rgb(15, 125, 75),\n            sidewalk: Color::grey(0.8),\n            sidewalk_lines: Color::grey(0.7),\n            general_road_marking: Color::WHITE,\n            road_center_line: Color::YELLOW,\n            light_rail_track: hex(\"#844204\"),\n            private_road: Some(hex(\"#F0B0C0\")),\n            unzoomed_highway: hex(\"#E892A2\"),\n            unzoomed_arterial: hex(\"#FFC73E\"),\n            unzoomed_residential: Color::WHITE,\n            unzoomed_cycleway: hex(\"#0F7D4B\"),\n            unzoomed_footway: hex(\"#DED68A\"),\n            // TODO Distinguish shared use and footway unzoomed or zoomed?\n            footway: hex(\"#DED68A\"),\n            shared_use: hex(\"#DED68A\"),\n\n            // Intersections\n            normal_intersection: Color::grey(0.2),\n            stop_sign: Color::RED,\n            stop_sign_pole: Color::grey(0.5),\n            signal_protected_turn: hex(\"#72CE36\"),\n            signal_permitted_turn: hex(\"#4CA7E9\"),\n            signal_banned_turn: hex(\"#EB3223\"),\n            signal_box: Color::grey(0.5),\n            signal_spinner: hex(\"#F2994A\"),\n            signal_turn_block_bg: Color::grey(0.6),\n\n            // Problems encountered on a trip\n            slowest_intersection: Color::RED,\n            slower_intersection: Color::YELLOW,\n            slow_intersection: Color::GREEN,\n\n            // Other static elements\n            void_background: Color::BLACK,\n            map_background: Color::grey(0.87).into(),\n            unzoomed_interesting_intersection: Color::BLACK,\n            residential_building: hex(\"#C4C1BC\"),\n            commercial_building: hex(\"#9FABA7\"),\n            building_outline: hex(\"#938E85\"),\n            parking_lot: Color::grey(0.7),\n            grass: hex(\"#94C84A\").into(),\n            water: hex(\"#A4C8EA\").into(),\n            study_area: hex(\"#96830C\").into(),\n\n            // Unzoomed dynamic elements\n            unzoomed_car: hex(\"#FE5f55\"),\n            unzoomed_bike: hex(\"#90BE6D\"),\n            unzoomed_bus: hex(\"#FFD166\"),\n            unzoomed_pedestrian: hex(\"#457B9D\"),\n\n            // Agents\n            agent_colors: vec![\n                hex(\"#5C45A0\"),\n                hex(\"#3E8BC3\"),\n                hex(\"#E1BA13\"),\n                hex(\"#96322F\"),\n                hex(\"#00A27B\"),\n            ],\n            route: Color::ORANGE.alpha(0.5),\n            turn_arrow: hex(\"#DF8C3D\"),\n            brake_light: hex(\"#FF1300\"),\n            bus_body: Color::rgb(50, 133, 117),\n            bus_label: Color::rgb(249, 206, 24),\n            train_body: hex(\"#42B6E9\"),\n            ped_head: Color::rgb(139, 69, 19),\n            ped_foot: Color::BLACK,\n            ped_preparing_bike_body: Color::rgb(255, 0, 144),\n            ped_crowd: Color::rgb_f(0.2, 0.7, 0.7),\n            bike_frame: hex(\"#AAA9AD\"),\n            parked_car: hex(\"#938E85\"),\n\n            // Layers\n            good_to_bad_red: ColorScale(vec![hex(\"#F19A93\"), hex(\"#A32015\")]),\n            good_to_bad_green: ColorScale(vec![hex(\"#BEDB92\"), hex(\"#397A4C\")]),\n            bus_layer: hex(\"#4CA7E9\"),\n            edits_layer: hex(\"#12409D\"),\n\n            // Misc\n            parking_trip: hex(\"#4E30A6\"),\n            bike_trip: Color::rgb(15, 125, 75),\n            bus_trip: Color::rgb(190, 74, 76),\n            before_changes: Color::BLUE,\n            after_changes: Color::RED,\n        }\n    }\n\n    // Shamelessly adapted from https://github.com/Uriopass/Egregoria\n    fn night_mode() -> ColorScheme {\n        let mut cs = ColorScheme::classic();\n        cs.scheme = ColorSchemeChoice::NightMode;\n        cs.gui_style = widgetry::Style::dark_bg();\n\n        cs.void_background = hex(\"#200A24\");\n        cs.map_background = Color::BLACK.into();\n        cs.grass = hex(\"#243A1F\").into();\n        cs.water = hex(\"#21374E\").into();\n        cs.residential_building = hex(\"#2C422E\");\n        cs.commercial_building = hex(\"#5D5F97\");\n\n        cs.driving_lane = hex(\"#404040\");\n        cs.parking_lane = hex(\"#353535\");\n        cs.sidewalk = hex(\"#6B6B6B\");\n        cs.general_road_marking = hex(\"#B1B1B1\");\n        cs.normal_intersection = cs.driving_lane;\n        cs.road_center_line = cs.general_road_marking;\n\n        cs.parking_lot = cs.sidewalk;\n        cs.unzoomed_highway = cs.parking_lane;\n        cs.unzoomed_arterial = cs.sidewalk;\n        cs.unzoomed_residential = cs.driving_lane;\n        cs.unzoomed_interesting_intersection = cs.unzoomed_highway;\n        cs.stop_sign = hex(\"#A32015\");\n        cs.private_road = Some(hex(\"#9E757F\"));\n        cs.study_area = hex(\"#D9B002\").into();\n\n        cs.panel_bg = cs.gui_style.panel_bg;\n        cs.inner_panel_bg = cs.panel_bg.alpha(1.0);\n        cs.minimap_cursor_border = Color::WHITE;\n        cs.minimap_cursor_bg = Some(Color::rgba(238, 112, 46, 0.2));\n\n        cs\n    }\n\n    fn textured() -> ColorScheme {\n        let mut cs = ColorScheme::day_mode();\n        cs.scheme = ColorSchemeChoice::Textured;\n        cs.grass = Texture::GRASS.into();\n        cs.water = Texture::STILL_WATER.into();\n        cs.map_background = Texture::CONCRETE.into();\n        cs\n    }\n\n    fn day_mode() -> ColorScheme {\n        let mut cs = Self::light_background(Style::light_bg());\n        cs.scheme = ColorSchemeChoice::DayMode;\n        cs.road_outlines = true;\n        cs.road_class_colors = true;\n        cs.show_buildings_in_minimap = false;\n\n        cs.map_background = hex(\"#EEE5C8\").into();\n        cs.grass = hex(\"#BED4A3\").into();\n        cs.water = hex(\"#6384D6\").into();\n\n        cs.sidewalk = hex(\"#A9A9A9\");\n        cs.sidewalk_lines = hex(\"#989898\");\n\n        cs.unzoomed_arterial = hex(\"#F6A483\");\n\n        cs.residential_building = hex(\"#C5D2E5\");\n        cs.commercial_building = hex(\"#99AECC\");\n\n        cs\n    }\n\n    fn ltn() -> ColorScheme {\n        let mut cs = ColorScheme::day_mode();\n        cs.scheme = ColorSchemeChoice::LTN;\n        cs.private_road = None;\n        cs.fade_map_dark = Color::BLACK.alpha(0.3);\n\n        // Based on Mapbox light scheme: https://www.mapbox.com/maps/light\n        cs.map_background = hex(\"#F6F6F4\").into();\n        // Water is #CAD2D3, but more blue\n        cs.water = hex(\"#c7d7d9\").into();\n        // #ECEEED, but more green\n        cs.grass = hex(\"#ddebe4\").into();\n        // Many maps would use line thickness to distinguish main and local roads, but we're stuck\n        // with geometric interpretation, so use black.\n        cs.unzoomed_highway = Color::BLACK;\n        cs.unzoomed_arterial = Color::BLACK;\n        cs.unzoomed_residential = Color::WHITE;\n        cs.unzoomed_cycleway = Color::CLEAR;\n        cs.unzoomed_footway = Color::CLEAR;\n        cs.light_rail_track = Color::CLEAR;\n\n        // The colors of cells will show through these, de-emphasizing them\n        cs.parking_lot = Color::BLACK.alpha(0.2);\n        cs.residential_building = Color::BLACK.alpha(0.3);\n        cs.commercial_building = Color::BLACK.alpha(0.5);\n\n        cs.gui_style.panel_bg = Color::WHITE;\n        cs.panel_bg = cs.gui_style.panel_bg;\n\n        cs\n    }\n}\n\nimpl ColorScheme {\n    pub fn rotating_color_plot(&self, idx: usize) -> Color {\n        modulo_color(\n            &[\n                Color::RED,\n                Color::BLUE,\n                Color::GREEN,\n                Color::PURPLE,\n                Color::BLACK,\n            ],\n            idx,\n        )\n    }\n\n    pub fn rotating_color_agents(&self, idx: usize) -> Color {\n        modulo_color(&self.agent_colors, idx)\n    }\n\n    pub fn unzoomed_road_surface(&self, rank: RoadRank) -> Color {\n        match rank {\n            RoadRank::Highway => self.unzoomed_highway,\n            RoadRank::Arterial => self.unzoomed_arterial,\n            RoadRank::Local => self.unzoomed_residential,\n        }\n    }\n\n    pub fn zoomed_road_surface(&self, lane: LaneType, rank: RoadRank) -> Color {\n        let main_asphalt = if self.road_class_colors {\n            match rank {\n                RoadRank::Highway => Color::grey(0.3),\n                RoadRank::Arterial => Color::grey(0.4),\n                RoadRank::Local => Color::grey(0.5),\n            }\n        } else {\n            self.driving_lane\n        };\n        let parking_asphalt = if self.road_class_colors {\n            main_asphalt\n        } else {\n            self.parking_lane\n        };\n\n        match lane {\n            LaneType::Driving => main_asphalt,\n            LaneType::Bus => self.bus_lane,\n            LaneType::Parking => parking_asphalt,\n            LaneType::Sidewalk | LaneType::Shoulder => self.sidewalk,\n            LaneType::Biking => self.bike_lane,\n            LaneType::SharedLeftTurn => main_asphalt,\n            LaneType::Construction => parking_asphalt,\n            LaneType::LightRail => unreachable!(),\n            LaneType::Buffer(_) => main_asphalt,\n            LaneType::Footway => self.footway,\n            LaneType::SharedUse => self.shared_use,\n        }\n    }\n    pub fn zoomed_intersection_surface(&self, rank: RoadRank) -> Color {\n        if self.road_class_colors {\n            self.zoomed_road_surface(LaneType::Driving, rank)\n        } else {\n            self.normal_intersection\n        }\n    }\n\n    pub fn curb(&self, rank: RoadRank) -> Color {\n        // The curb should be darker than the asphalt to stand out\n        match rank {\n            RoadRank::Highway => Color::grey(0.2),\n            RoadRank::Arterial => Color::grey(0.3),\n            RoadRank::Local => Color::grey(0.4),\n        }\n    }\n\n    pub fn road_center_line(&self, map: &Map) -> Color {\n        // TODO A more robust approach is to offload this question to osm2lanes, and color by\n        // separators\n        if map.get_name().city.country == \"gb\" {\n            self.general_road_marking\n        } else {\n            self.road_center_line\n        }\n    }\n\n    // These two could try to use serde, but... Color serializes with a separate RGB by default,\n    // and changing it to use a nice hex string is way too hard.\n    pub fn export(&self, path: &str) -> Result<()> {\n        let mut f = File::create(path)?;\n        writeln!(f, \"unzoomed_highway {}\", self.unzoomed_highway.as_hex())?;\n        writeln!(f, \"unzoomed_arterial {}\", self.unzoomed_arterial.as_hex())?;\n        writeln!(\n            f,\n            \"unzoomed_residential {}\",\n            self.unzoomed_residential.as_hex()\n        )?;\n        writeln!(f, \"unzoomed_cycleway {}\", self.unzoomed_cycleway.as_hex())?;\n        writeln!(f, \"unzoomed_footway {}\", self.unzoomed_footway.as_hex())?;\n        writeln!(\n            f,\n            \"residential_building {}\",\n            self.residential_building.as_hex()\n        )?;\n        writeln!(\n            f,\n            \"commercial_building {}\",\n            self.commercial_building.as_hex()\n        )?;\n        if let Fill::Color(c) = self.grass {\n            writeln!(f, \"grass {}\", c.as_hex())?;\n        }\n        if let Fill::Color(c) = self.water {\n            writeln!(f, \"water {}\", c.as_hex())?;\n        }\n        Ok(())\n    }\n\n    pub fn import(&mut self, path: &str) -> Result<()> {\n        let raw = String::from_utf8(abstio::slurp_file(path)?)?;\n        let mut colors = Vec::new();\n        for line in raw.split('\\n') {\n            if line.is_empty() {\n                continue;\n            }\n            let mut parts = line.split(' ');\n            parts.next();\n            colors.push(Color::hex(parts.next().unwrap()));\n        }\n\n        self.unzoomed_highway = colors[0];\n        self.unzoomed_arterial = colors[1];\n        self.unzoomed_residential = colors[2];\n        self.unzoomed_cycleway = colors[3];\n        self.unzoomed_footway = colors[4];\n        self.residential_building = colors[5];\n        self.commercial_building = colors[6];\n        self.grass = Fill::Color(colors[7]);\n        self.water = Fill::Color(colors[8]);\n\n        Ok(())\n    }\n}\n\nfn modulo_color(colors: &[Color], idx: usize) -> Color {\n    colors[idx % colors.len()]\n}\n\n// Convenience\nfn hex(x: &str) -> Color {\n    Color::hex(x)\n}\n\n\n# traffic_seitan/Cargo.toml:\n[package]\nname = \"traffic_seitan\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[dependencies]\nabstutil = { path = \"../abstutil\" }\ngeom = { workspace = true }\nlog = { workspace = true }\nmap_model = { path = \"../map_model\" }\nrand = { workspace = true }\nrand_xorshift = { workspace = true }\nsim = { path = \"../sim\" }\nstructopt = { workspace = true }\n\n\n# map_model/Cargo.toml:\n[package]\nname = \"map_model\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\nenumset = { version = \"1.1.3\", features=[\"serde\"] }\nfast_paths = { git = \"https://github.com/easbar/fast_paths\", rev = \"9a954e02f01ed16939d3c4a2dc9dd3fb4f6c03ee\"}\ngeojson = { workspace = true }\ngeom = { workspace = true }\nkml = { path = \"../kml\" }\nlog = { workspace = true }\nlyon = \"1.0.1\"\nmd5 = \"0.7.0\"\npetgraph = { version = \"0.6.4\", features=[\"serde-1\"] }\npopgetter = { path = \"../popgetter\" }\nrand = { workspace = true }\nrand_xorshift = { workspace = true }\nraw_map = { path = \"../raw_map\" }\nserde = { workspace = true, features=[\"derive\"] }\nserde_json = { workspace = true }\nosm2streets = { git = \"https://github.com/a-b-street/osm2streets\" }\nstructopt = { workspace = true }\nthread_local = \"1.1.7\"\n\n\n# map_model/src/pathfind/mod.rs:\n//! Everything related to pathfinding through a map for different types of agents.\n\nuse std::collections::BTreeSet;\n\nuse enumset::EnumSetType;\nuse serde::{Deserialize, Serialize};\n\nuse geom::Duration;\n\npub use self::engine::CreateEngine;\npub use self::pathfinder::{Pathfinder, PathfinderCache, PathfinderCaching};\npub use self::v1::{Path, PathRequest, PathStep};\npub use self::v2::{PathStepV2, PathV2};\npub use self::vehicles::vehicle_cost;\npub use self::walking::WalkingNode;\nuse crate::{osm, Lane, LaneID, LaneType, Map, MovementID, Road, RoadID, TurnType};\n\nmod engine;\nmod node_map;\nmod pathfinder;\n// TODO tmp\npub mod uber_turns;\nmod v1;\nmod v2;\nmod vehicles;\nmod walking;\n\n/// Who's asking for a path?\n// TODO This is an awful name.\n#[derive(Debug, Serialize, Deserialize, PartialOrd, Ord, EnumSetType)]\npub enum PathConstraints {\n    Pedestrian,\n    Car,\n    Bike,\n    Bus,\n    Train,\n}\n\nimpl PathConstraints {\n    pub fn all() -> Vec<PathConstraints> {\n        vec![\n            PathConstraints::Pedestrian,\n            PathConstraints::Car,\n            PathConstraints::Bike,\n            PathConstraints::Bus,\n            PathConstraints::Train,\n        ]\n    }\n\n    /// Not bijective, but this is the best guess of user intent\n    pub fn from_lt(lt: LaneType) -> PathConstraints {\n        match lt {\n            LaneType::Sidewalk | LaneType::Shoulder => PathConstraints::Pedestrian,\n            LaneType::Driving => PathConstraints::Car,\n            LaneType::Biking => PathConstraints::Bike,\n            LaneType::Bus => PathConstraints::Bus,\n            LaneType::LightRail => PathConstraints::Train,\n            _ => panic!(\"PathConstraints::from_lt({:?}) doesn't make sense\", lt),\n        }\n    }\n\n    /// Can an agent use a lane? There are some subtle exceptions with using bus-only lanes for\n    /// turns.\n    pub fn can_use(self, lane: &Lane, map: &Map) -> bool {\n        let result = match self {\n            PathConstraints::Pedestrian => {\n                return lane.is_walkable();\n            }\n            PathConstraints::Car => lane.is_driving(),\n            PathConstraints::Bike => {\n                if lane.is_biking() {\n                    true\n                } else if lane.is_driving() || (lane.is_bus() && map.config.bikes_can_use_bus_lanes)\n                {\n                    let road = map.get_r(lane.id.road);\n                    !road.osm_tags.is(\"bicycle\", \"no\")\n                        && !road\n                            .osm_tags\n                            .is_any(osm::HIGHWAY, vec![\"motorway\", \"motorway_link\"])\n                } else {\n                    false\n                }\n            }\n            PathConstraints::Bus => {\n                return lane.is_driving() || lane.is_bus();\n            }\n            PathConstraints::Train => {\n                return lane.is_light_rail();\n            }\n        };\n        if result {\n            return true;\n        }\n        // Second chance for cars and bikes trying to use a bus-only lane that also happens to be a\n        // turn lane.\n        //\n        // TODO This check could be made stricter in two ways:\n        // 1) Verify that the bus-only lanes are the ONLY way to make this movement; if there's a\n        //    general purpose lane that can also turn, we shouldn't allow this.\n        // 2) Verify that the turn->lane->turn sequence is the only way to reach the destination\n        //    road. Since this function operates on a single lane, a vehicle could abuse this to\n        //    stay in the bus lane and go straight, even if there was another lane for that. Fixing\n        //    this is hard, since it requires so much context about the sequence of movements. In\n        //    practice this isn't an issue; a bus lane often leads to another one, but the next bus\n        //    lane won't also be an exclusive turn lane.\n        if lane.is_bus() {\n            if let Some(types) =\n                lane.get_lane_level_turn_restrictions(map.get_r(lane.id.road), true)\n            {\n                if types.contains(&TurnType::Right) || types.contains(&TurnType::Left) {\n                    return true;\n                }\n            }\n        }\n        false\n    }\n\n    /// Can an agent use a road in either direction? There are some subtle exceptions with using\n    /// bus-only lanes for turns.\n    pub fn can_use_road(self, road: &Road, map: &Map) -> bool {\n        road.lanes.iter().any(|lane| self.can_use(lane, map))\n    }\n\n    /// Strict for bikes. If there are bike lanes, not allowed to use other lanes.\n    pub(crate) fn filter_lanes(self, mut choices: Vec<LaneID>, map: &Map) -> Vec<LaneID> {\n        choices.retain(|l| self.can_use(map.get_l(*l), map));\n        if self == PathConstraints::Bike {\n            let just_bike_lanes: Vec<LaneID> = choices\n                .iter()\n                .copied()\n                .filter(|l| map.get_l(*l).is_biking())\n                .collect();\n            if !just_bike_lanes.is_empty() {\n                return just_bike_lanes;\n            }\n        }\n        choices\n    }\n}\n\n/// Heavily penalize crossing into an access-restricted zone that doesn't allow this mode.\npub(crate) fn zone_cost(mvmnt: MovementID, constraints: PathConstraints, map: &Map) -> Duration {\n    // Detect when we cross into a new zone that doesn't allow constraints.\n    if map\n        .get_r(mvmnt.from.road)\n        .access_restrictions\n        .allow_through_traffic\n        .contains(constraints)\n        && !map\n            .get_r(mvmnt.to.road)\n            .access_restrictions\n            .allow_through_traffic\n            .contains(constraints)\n    {\n        // This should be high enough to achieve the desired effect of somebody not entering\n        // the zone unless absolutely necessary. Someone would violate that and cut through anyway\n        // only when the alternative route would take more than 3 hours longer!\n        Duration::hours(3)\n    } else {\n        Duration::ZERO\n    }\n}\n\n/// Tuneable parameters for all types of routing.\n// These will maybe become part of the PathRequest later, but that's an extremely invasive and\n// space-expensive change right now.\n#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]\npub struct RoutingParams {\n    // For all vehicles. This is added to the cost of a movement as an additional delay.\n    pub unprotected_turn_penalty: Duration,\n\n    // For bike routing. Multiplied by the base cost, since spending more time on the wrong lane\n    // type matters.\n    pub bike_lane_penalty: f64,\n    pub bus_lane_penalty: f64,\n    pub driving_lane_penalty: f64,\n\n    // For bike routing.\n    // \"Steep\" is a fixed threshold of 8% incline, uphill only. Multiply by the base cost. (Note\n    // that cost already includes a reduction of speed to account for the incline -- this is a\n    // further \"delay\" on top of that!)\n    // TODO But even steeper roads matter more!\n    pub avoid_steep_incline_penalty: f64,\n    // If the road is `high_stress_for_bikes`, multiply by the base cost.\n    pub avoid_high_stress: f64,\n\n    /// When crossing an arterial or highway road, multiply the base cost by this penalty. When\n    /// greater than 1, this will encourage routes to use local roads more.\n    pub main_road_penalty: f64,\n\n    /// Don't allow crossing these roads at all. Only affects vehicle routing, not pedestrian.\n    ///\n    /// TODO The route may cross one of these roads if it's the start or end!\n    pub avoid_roads: BTreeSet<RoadID>,\n    /// Related to `avoid_roads`, but used as an optimization in map construction\n    pub only_use_roads: BTreeSet<RoadID>,\n\n    /// Don't allow movements between these roads at all. Only affects vehicle routing, not\n    /// pedestrian.\n    pub avoid_movements_between: BTreeSet<(RoadID, RoadID)>,\n}\n\nimpl Default for RoutingParams {\n    fn default() -> Self {\n        Self {\n            // This is a total guess -- it really depends on the traffic patterns of the particular\n            // road at the time we're routing.\n            unprotected_turn_penalty: Duration::const_seconds(30.0),\n\n            bike_lane_penalty: 1.0,\n            bus_lane_penalty: 1.1,\n            driving_lane_penalty: 1.5,\n\n            avoid_steep_incline_penalty: 1.0,\n            avoid_high_stress: 1.0,\n\n            main_road_penalty: 1.0,\n\n            avoid_roads: BTreeSet::new(),\n            avoid_movements_between: BTreeSet::new(),\n            only_use_roads: BTreeSet::new(),\n        }\n    }\n}\n\npub fn round(cost: Duration) -> usize {\n    // Round up! 0 cost edges are ignored\n    (cost.inner_seconds().round() as usize).max(1)\n}\n\npub fn unround(cost: usize) -> Duration {\n    Duration::seconds(cost as f64)\n}\n\n\n# updater/Cargo.toml:\n[package]\nname = \"updater\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\nflate2 = { workspace = true }\nfs-err = { workspace = true }\nfutures-channel = { workspace = true }\nmd5 = \"0.7.0\"\nstructopt = { workspace = true }\ntokio = { workspace = true }\nwalkdir = \"2.4.0\"\n\n\n# updater/src/main.rs:\nuse std::collections::BTreeMap;\nuse std::io::{BufReader, Read};\nuse std::process::Command;\n\nuse anyhow::Result;\nuse fs_err::File;\nuse structopt::StructOpt;\nuse walkdir::WalkDir;\n\nuse abstio::{DataPacks, Entry, Manifest};\nuse abstutil::{must_run_cmd, prettyprint_usize, Timer};\n\nconst MD5_BUF_READ_SIZE: usize = 4096;\n\n#[derive(StructOpt)]\n#[structopt(\n    name = \"updater\",\n    about = \"Download the latest version of per-city data\"\n)]\nenum Task {\n    /// Synchronize the source-of-truth in S3 with data in the local directory. Based on current\n    /// permissions, only Dustin runs this.\n    Upload,\n    /// This uploads to S3 from cloud VMs that import maps. This never deletes files from S3, only\n    /// updates or creates ne ones.\n    IncrementalUpload {\n        /// Upload data to a temporary version managed by the cloud scripts.\n        #[structopt(long)]\n        version: String,\n    },\n    /// Just compare data in the current directory with the manifest, and describe any new,\n    /// deleted, or modified files.\n    DryRun {\n        /// Just check if one file has changed.\n        #[structopt(long)]\n        single_file: Option<String>,\n    },\n    /// Print the JSON list of all possible city data packs to download. You can write this output\n    /// to `data/player/data.json`, then download everything.\n    OptIntoAll,\n    /// Synchronize the local `data` directory with the source-of-truth in S3.\n    Download {\n        /// The Github Actions build uses this to include only a few files for the release to be\n        /// usable. People can use the UI to open another map and download more data.\n        #[structopt(long)]\n        minimal: bool,\n        /// Only update files from the manifest. Leave extra files alone.\n        #[structopt(long)]\n        dont_delete: bool,\n        /// Only useful for Dustin. \"Download\" from my local S3 source-of-truth, not from the\n        /// network.\n        #[structopt(long)]\n        dl_from_local: bool,\n        /// Download data tied to a named release. See\n        /// https://a-b-street.github.io/docs/tech/dev/data.html.\n        #[structopt(long, default_value = \"dev\")]\n        version: String,\n    },\n}\n\n#[tokio::main]\nasync fn main() {\n    if !std::path::Path::new(\"data\").exists() {\n        panic!(\"Your current directory doesn't have the data/ directory. Run from the git root: cd ../; cargo run --bin updater -- args\");\n    }\n\n    abstutil::logger::setup();\n    match Task::from_args() {\n        Task::Upload => {\n            upload(\"dev\");\n        }\n        Task::IncrementalUpload { version } => {\n            // We DON'T want to override the main data immediately from the batch Docker jobs. If\n            // running locally, can temporarily disable this assertion.\n            assert_ne!(version, \"dev\");\n            incremental_upload(version);\n        }\n        Task::DryRun { single_file } => {\n            if let Some(path) = single_file {\n                let local = md5sum(&path);\n                let truth = Manifest::load()\n                    .entries\n                    .remove(&path)\n                    .unwrap_or_else(|| panic!(\"{} not in data/MANIFEST.txt\", path))\n                    .checksum;\n                if local != truth {\n                    println!(\"{} has changed\", path);\n                }\n            } else {\n                just_compare();\n            }\n        }\n        Task::OptIntoAll => {\n            println!(\"{}\", abstutil::to_json(&DataPacks::all_data_packs()));\n        }\n        Task::Download {\n            minimal,\n            dont_delete,\n            dl_from_local,\n            version,\n        } => {\n            download_updates(version, minimal, !dont_delete, dl_from_local).await;\n        }\n    }\n}\n\nasync fn download_updates(version: String, minimal: bool, delete_local: bool, dl_from_local: bool) {\n    let data_packs = DataPacks::load_or_create();\n    let truth = Manifest::load().filter(data_packs);\n    let local = generate_manifest(&truth);\n\n    // Anything local need deleting?\n    if delete_local {\n        for path in local.entries.keys() {\n            if !truth.entries.contains_key(path) {\n                rm(path);\n            }\n        }\n    }\n\n    // Anything missing or needing updating?\n    let mut failed = Vec::new();\n    for (path, entry) in truth.entries {\n        if local.entries.get(&path).map(|x| &x.checksum) != Some(&entry.checksum) {\n            if minimal && !path.contains(\"montlake\") && path != \"data/system/us/seattle/city.bin\" {\n                continue;\n            }\n\n            fs_err::create_dir_all(std::path::Path::new(&path).parent().unwrap()).unwrap();\n            match download_file(&version, &path, dl_from_local).await {\n                Ok(bytes) => {\n                    println!(\n                        \"> decompress {}, which is {} bytes compressed\",\n                        path,\n                        prettyprint_usize(bytes.len())\n                    );\n                    let mut decoder = flate2::read::GzDecoder::new(&bytes[..]);\n                    let mut out = File::create(&path).unwrap();\n                    if let Err(err) = std::io::copy(&mut decoder, &mut out) {\n                        println!(\"{}, but continuing\", err);\n                        failed.push(format!(\"{} failed: {}\", path, err));\n                    }\n                }\n                Err(err) => {\n                    println!(\"{}, but continuing\", err);\n                    failed.push(format!(\"{} failed: {}\", path, err));\n                }\n            };\n        }\n    }\n    if !failed.is_empty() {\n        // Fail the build.\n        panic!(\"Failed to download stuff: {:?}\", failed);\n    }\n\n    remove_empty_directories(\"data/input\");\n    remove_empty_directories(\"data/system\");\n}\n\nfn just_compare() {\n    let data_packs = DataPacks::load_or_create();\n    let truth = Manifest::load().filter(data_packs);\n    let local = generate_manifest(&truth);\n\n    // Anything local need deleting?\n    for path in local.entries.keys() {\n        if !truth.entries.contains_key(path) {\n            println!(\"- Remove {}\", path);\n        }\n    }\n\n    // Anything missing or needing updating?\n    for (path, entry) in truth.entries {\n        if local.entries.get(&path).map(|x| &x.checksum) != Some(&entry.checksum) {\n            if let Some(old_bytes) = local.entries.get(&path).map(|x| x.uncompressed_size_bytes) {\n                if old_bytes == entry.uncompressed_size_bytes {\n                    println!(\"- Update {}. Same size, md5sum changed\", path);\n                } else {\n                    println!(\n                        \"- Update {}. {} bytes difference\",\n                        path,\n                        (old_bytes as isize) - (entry.uncompressed_size_bytes as isize)\n                    );\n                }\n            } else {\n                println!(\"- Add {}\", path);\n            }\n        }\n    }\n}\n\nfn upload(version: &str) {\n    let remote_base = format!(\"/home/dabreegster/s3_abst_data/{}\", version);\n\n    let remote: Manifest = abstio::maybe_read_json(\n        format!(\"{}/MANIFEST.json\", remote_base),\n        &mut Timer::throwaway(),\n    )\n    .unwrap_or(Manifest {\n        entries: BTreeMap::new(),\n    });\n    let mut local = generate_manifest(&remote);\n\n    // Anything remote need deleting?\n    for path in remote.entries.keys() {\n        if !local.entries.contains_key(path) {\n            rm(&format!(\"{}/{}.gz\", remote_base, path));\n        }\n    }\n\n    // Anything missing or needing updating?\n    let local_entries = std::mem::take(&mut local.entries);\n    for (path, entry) in Timer::new(\"compress files\").parallelize(\n        \"compress files\",\n        local_entries.into_iter().collect(),\n        |(path, mut entry)| {\n            let remote_path = format!(\"{}/{}.gz\", remote_base, path);\n            let changed = remote.entries.get(&path).map(|x| &x.checksum) != Some(&entry.checksum);\n            if changed {\n                compress(&path, &remote_path);\n            }\n            // Always do this -- even if nothing changed, compressed_size_bytes isn't filled out by\n            // generate_manifest.\n            entry.compressed_size_bytes = fs_err::metadata(&remote_path)\n                .unwrap_or_else(|_| panic!(\"Compressed {} not there?\", remote_path))\n                .len();\n            (path, entry)\n        },\n    ) {\n        local.entries.insert(path, entry);\n    }\n\n    abstio::write_json(format!(\"{}/MANIFEST.json\", remote_base), &local);\n    abstio::write_json(\"data/MANIFEST.json\".to_string(), &local);\n\n    must_run_cmd(\n        Command::new(\"aws\")\n            .arg(\"s3\")\n            .arg(\"sync\")\n            .arg(\"--delete\")\n            .arg(format!(\"{}/data\", remote_base))\n            .arg(format!(\"s3://abstreet/{}/data\", version)),\n    );\n    // Because of the directory structure, do this one separately, without --delete. The wasm files\n    // also live in /dev/.\n    must_run_cmd(\n        Command::new(\"aws\")\n            .arg(\"s3\")\n            .arg(\"cp\")\n            .arg(format!(\"{}/MANIFEST.json\", remote_base))\n            .arg(format!(\"s3://abstreet/{}/MANIFEST.json\", version)),\n    );\n}\n\nfn incremental_upload(version: String) {\n    let remote_base = \"tmp_incremental_upload\";\n\n    // Assume the local copy of the manifest from git is the current source of truth.\n    let mut truth = Manifest::load();\n    let local = generate_manifest(&truth);\n\n    // Anything missing or needing updating?\n    let mut changes = false;\n    for (path, entry) in Timer::new(\"compress files\")\n        .parallelize(\n            \"compress files\",\n            local.entries.into_iter().collect(),\n            |(path, mut entry)| {\n                if truth.entries.get(&path).map(|x| &x.checksum) != Some(&entry.checksum) {\n                    let remote_path = format!(\"{}/{}.gz\", remote_base, path);\n                    compress(&path, &remote_path);\n                    entry.compressed_size_bytes = fs_err::metadata(&remote_path)\n                        .unwrap_or_else(|_| panic!(\"Compressed {} not there?\", remote_path))\n                        .len();\n                    Some((path, entry))\n                } else {\n                    None\n                }\n            },\n        )\n        .into_iter()\n        .flatten()\n    {\n        truth.entries.insert(path, entry);\n        changes = true;\n    }\n    if !changes {\n        return;\n    }\n\n    // TODO /home/dabreegster/s3_abst_data/{version}/MANIFEST.json will get out of sync...\n    abstio::write_json(\"data/MANIFEST.json\".to_string(), &truth);\n\n    must_run_cmd(\n        Command::new(\"aws\")\n            .arg(\"s3\")\n            .arg(\"sync\")\n            .arg(format!(\"{}/data\", remote_base))\n            .arg(format!(\"s3://abstreet/{}/data\", version)),\n    );\n    // Upload the new manifest file to S3.\n    // TODO This won't work from AWS Batch; the workers will stomp over each other.\n    must_run_cmd(\n        Command::new(\"aws\")\n            .arg(\"s3\")\n            .arg(\"cp\")\n            .arg(\"data/MANIFEST.json\")\n            .arg(format!(\"s3://abstreet/{}/MANIFEST.json\", version)),\n    );\n\n    // Nuke the temporary workspace\n    must_run_cmd(Command::new(\"rm\").arg(\"-rfv\").arg(remote_base));\n}\n\nfn generate_manifest(truth: &Manifest) -> Manifest {\n    let mut paths = Vec::new();\n    for entry in WalkDir::new(\"data/input\")\n        .into_iter()\n        .chain(WalkDir::new(\"data/system\").into_iter())\n        .filter_map(|e| e.ok())\n    {\n        if entry.file_type().is_dir() {\n            continue;\n        }\n        let orig_path = entry.path().display().to_string();\n        let path = orig_path.replace(\"\\\\\", \"/\");\n        if path.contains(\"system/assets/\")\n            || path.contains(\"system/ltn_proposals\")\n            || path.contains(\"system/proposals\")\n            || path.contains(\"system/study_areas\")\n        {\n            continue;\n        }\n        if path.ends_with(\".osm\") {\n            continue;\n        }\n        paths.push((orig_path, path));\n    }\n\n    let mut kv = BTreeMap::new();\n    for (path, entry) in\n        Timer::new(\"compute md5sums\").parallelize(\"compute md5sums\", paths, |(orig_path, path)| {\n            // If the file's modtime is newer than 12 hours or the uncompressed size has changed,\n            // calculate md5sum. Otherwise assume no change. This heuristic saves lots of time and\n            // doesn't stress my poor SSD as much.\n            let metadata = fs_err::metadata(&orig_path).unwrap();\n            let uncompressed_size_bytes = metadata.len();\n            let recent_modtime = metadata.modified().unwrap().elapsed().unwrap()\n                < std::time::Duration::from_secs(60 * 60 * 12);\n\n            let checksum = if recent_modtime\n                || truth\n                    .entries\n                    .get(&path)\n                    .map(|entry| entry.uncompressed_size_bytes != uncompressed_size_bytes)\n                    .unwrap_or(true)\n            {\n                md5sum(&orig_path)\n            } else {\n                truth.entries[&path].checksum.clone()\n            };\n            (\n                path,\n                Entry {\n                    checksum,\n                    uncompressed_size_bytes,\n                    // Will calculate later\n                    compressed_size_bytes: 0,\n                },\n            )\n        })\n    {\n        kv.insert(path, entry);\n    }\n\n    Manifest { entries: kv }\n}\n\nfn md5sum(path: &str) -> String {\n    // since these files can be very large, computes the md5 hash in chunks\n    let mut file = File::open(path).unwrap();\n    let mut buffer = [0_u8; MD5_BUF_READ_SIZE];\n    let mut context = md5::Context::new();\n    while let Ok(n) = file.read(&mut buffer) {\n        if n == 0 {\n            break;\n        }\n        context.consume(&buffer[..n]);\n    }\n    format!(\"{:x}\", context.compute())\n}\n\nfn rm(path: &str) {\n    println!(\"> rm {}\", path);\n    match fs_err::remove_file(path) {\n        Ok(_) => {}\n        Err(e) => match e.kind() {\n            std::io::ErrorKind::NotFound => {\n                println!(\"file {} does not exist, continuing\", &path);\n            }\n            other_error => {\n                panic!(\"problem removing file: {:?}\", other_error);\n            }\n        },\n    }\n}\n\nasync fn download_file(version: &str, path: &str, dl_from_local: bool) -> Result<Vec<u8>> {\n    if dl_from_local {\n        return abstio::slurp_file(format!(\n            \"/home/dabreegster/s3_abst_data/{}/{}.gz\",\n            version, path\n        ));\n    }\n\n    let url = format!(\"https://play.abstreet.org/{}/{}.gz\", version, path);\n    println!(\"> download {}\", url);\n    let (mut tx, rx) = futures_channel::mpsc::channel(1000);\n    abstio::print_download_progress(rx);\n    abstio::download_bytes(url, None, &mut tx).await\n}\n\n// download() will remove stray files, but leave empty directories around. Since some runtime code\n// discovers lists of countries, cities, etc from the filesystem, this can get confusing.\n//\n// I'm sure there's a simpler way to do this, but I haven't found it.\nfn remove_empty_directories(root: &str) {\n    loop {\n        // First just find all directories and files.\n        let mut all_paths = Vec::new();\n        let mut all_dirs = Vec::new();\n        for entry in WalkDir::new(root).into_iter().filter_map(|e| e.ok()) {\n            let path = entry.path().display().to_string();\n            all_paths.push(path.clone());\n            if entry.file_type().is_dir() {\n                all_dirs.push(path);\n            }\n        }\n\n        // Now filter out directories that're a prefix of some path.\n        all_dirs.retain(|dir| !all_paths.iter().any(|p| p != dir && p.starts_with(dir)));\n\n        if all_dirs.is_empty() {\n            break;\n        } else {\n            // Remove them! Then repeat, since we might have nested/empty/directories/.\n            for x in all_dirs {\n                println!(\"> Removing empty directory {}\", x);\n                // This fails if the directory isn't empty, which is a good sanity check. If\n                // something weird happened, just bail.\n                fs_err::remove_dir(&x).unwrap();\n            }\n        }\n    }\n}\n\nfn compress(path: &str, remote_path: &str) {\n    assert!(!path.ends_with(\".gz\"));\n    assert!(remote_path.ends_with(\".gz\"));\n\n    fs_err::create_dir_all(std::path::Path::new(remote_path).parent().unwrap()).unwrap();\n    println!(\"> compressing {}\", path);\n    let mut input = BufReader::new(File::open(path).unwrap());\n    let out = File::create(remote_path).unwrap();\n    let mut encoder = flate2::write::GzEncoder::new(out, flate2::Compression::best());\n    std::io::copy(&mut input, &mut encoder).unwrap();\n    encoder.finish().unwrap();\n}\n\n\n# release/update_docs.sh:\n#!/bin/bash\n# Manually run after pushing the Github release\n\nset -e\n\nOLD_MAJOR=0\nOLD_MINOR=3\nOLD_PATCH=$1\n\nNEW_MAJOR=0\nNEW_MINOR=3\nNEW_PATCH=$2\n\nif [ \"$OLD_PATCH\" == \"\" ] || [ \"$NEW_PATCH\" == \"\" ]; then\n\techo Missing args;\n\texit 1;\nfi\n\n# This assumes https://github.com/a-b-street/docs is checked out at ~/docs\nperl -pi -e \"s/${OLD_MAJOR}_${OLD_MINOR}_${OLD_PATCH}/${NEW_MAJOR}_${NEW_MINOR}_${NEW_PATCH}/g\" README.md ~/docs/book/src/user/README.md ~/docs/book/src/software/*.md ~/docs/book/src/software/*/*.md ~/docs/book/src/proposals/*/*.md\nperl -pi -e \"s/${OLD_MAJOR}\\.${OLD_MINOR}\\.${OLD_PATCH}/${NEW_MAJOR}\\.${NEW_MINOR}\\.${NEW_PATCH}/g\" README.md ~/docs/book/src/user/README.md ~/docs/book/src/software/*.md ~/docs/book/src/software/*/*.md ~/docs/book/src/proposals/*/*.md\n\necho \"Don't forget to:\"\necho \"1) ./release/deploy_web.sh\"\necho \"2) aws s3 cp --recursive --exclude 'data/input/*' s3://abstreet/dev/ s3://abstreet/${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}\"\necho \"3) Update map_gui/src/tools/mod.rs\"\necho \"4) Push the docs repo too\"\n\n\n# release/deploy_actdev.sh:\n#!/bin/bash\n# This is like deploy_web.sh, but just creates a directory for https://github.com/cyipt/actdev\n#\n# IMPORTANT: First run deploy_web.sh to actually build everything. This script\n# assumes web/build/dist is up-to-date.\n\nset -x\nset -e\n\nmkdir abst_actdev\ncp -Rv web/build/dist/abstreet* abst_actdev\n# We're not packaging multiple apps, so set the index.html\nmv abst_actdev/abstreet.html abst_actdev/index.html\n\n# Copy just what's needed from data\nmkdir -p abst_actdev/data/system/gb\n# We could just copy all of system/gb and remove leeds and london, but\n# actually, having this list in a script somewhere is kind of convenient.\nfor dir in allerton_bywater ashton_park aylesbury aylesham bailrigg bath_riverside bicester castlemead chapelford chapeltown_cohousing clackers_brook cricklewood culm dickens_heath didcot dunton_hills ebbsfleet exeter_red_cow_village great_kneighton halsnead hampton handforth kergilliack kidbrooke_village lcid lockleaze long_marston marsh_barton micklefield newborough_road newcastle_great_park northwick_park poundbury priors_hall taunton_firepool taunton_garden tresham trumpington_meadows tyersal_lane upton water_lane wichelstowe wixams wynyard; do\n\tcp -Rv data/system/gb/$dir abst_actdev/data/system/gb\ndone\ncp -Rv data/system/study_areas abst_actdev/data/system\ngzip -v `find abst_actdev/ | grep bin | xargs`\n\nzip -r abst_actdev abst_actdev\nrm -rf abst_actdev\necho \"Go upload abst_actdev.zip to https://github.com/cyipt/actdev/releases\"\n\n\n# release/build.sh:\n#!/bin/bash\n# Called by Github Actions workflow\n\nset -e;\n\nos=$1;\ncase $os in\n    ubuntu-20.04)\n        output=\"abst_linux\";\n        suffix=\"\";\n        ;;\n\n    macos-latest)\n        output=\"abst_mac\";\n        suffix=\"\";\n        ;;\n\n    windows-latest)\n        output=\"abst_windows\";\n        suffix=\".exe\";\n        ;;\n\n    *)\n        echo \"Wat? os = $os\";\n        exit 1;\nesac\n\nmkdir $output\nmkdir $output/binaries\n\ncp release/INSTRUCTIONS.txt $output\n\nfor name in game cli fifteen_min osm_viewer parking_mapper santa ltn; do\n    bin=\"target/release/${name}${suffix}\"\n    if [[ \"$output\" = \"abst_mac\" ]]; then\n        # If this errors or hangs, ensure you've imported and unlocked a\n        # keychain holding a codesigning certificate with a Common Name\n        # matching \"Developer ID Application.*\"\n        codesign -fs \"Developer ID Application\" --timestamp -o runtime \"$bin\"\n    fi\n    cp $bin $output/binaries;\ndone\n\n# Generate a script to run each app and capture output logs\n# Note these're different than the executable names\nfor name in play_abstreet ungap_the_map fifteen_min osm_viewer parking_mapper santa ltn; do\n\tif [[ \"$os\" = \"windows-latest\" ]]; then\n\t\tcase $name in\n\t\t\tplay_abstreet)\n\t\t\t\tcmd=\".\\\\binaries\\\\game.exe\";\n\t\t\t\t;;\n\t\t\tungap_the_map)\n\t\t\t\tcmd=\".\\\\binaries\\\\game.exe --ungap\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tcmd=\".\\\\binaries\\\\${name}.exe\";\n\t\t\t\t;;\n\t\tesac\n\n\t\tscript=\"${output}/${name}.bat\"\n\t\techo 'set RUST_BACKTRACE=1' > $script\n\t\techo \"${cmd} 1> output.txt 2>&1\" >> $script\n\telse\n\t\tcase $name in\n\t\t\tplay_abstreet)\n\t\t\t\tcmd=\"./binaries/game\";\n\t\t\t\t;;\n\t\t\tungap_the_map)\n\t\t\t\tcmd=\"./binaries/game --ungap\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tcmd=\"./binaries/${name}\";\n\t\t\t\t;;\n\t\tesac\n\n\t\tscript=\"${output}/${name}.sh\"\n\t\techo '#!/bin/bash' > $script\n\t\techo 'echo See logs in output.txt' >> $script\n\t\techo \"RUST_BACKTRACE=1 ${cmd} 1> output.txt 2>&1\" >> $script\n\tfi\n\tchmod +x $script\ndone\n\nmkdir $output/data\ncp -Rv data/system $output/data/system\ncp data/MANIFEST.json $output/data\n\ncase $os in\n    ubuntu-20.04)\n        # TODO Github will double-zip this, but if we just pass the directory, then the\n        # chmod +x bits get lost\n        zip -r $output $output\n        rm -rf $output\n        ;;\n\n    macos-latest)\n        ditto -c -k --keepParent $output $output.zip\n        xcrun notarytool submit --wait \\\n            --apple-id $MACOS_DEVELOPER_APPLE_ID \\\n            --team-id $MACOS_DEVELOPER_TEAM_ID \\\n            --password $MACOS_DEVELOPER_APP_SPECIFIC_PASSWORD \\\n            $output.zip\n\n        # TODO: staple the notarization so users can launch the app while\n        # offline without warning. There's no way to staple the notarization to\n        # raw binaries. To staple the notarization we need to adapting to a\n        # .dmg, .pkg, or .app compatible installation. So until that happens,\n        # users will need to be online the first time they launch the binary,\n        # else they'll see the dreaded error:\n        #\n        # >  can\u2019t be opened because Apple cannot check it for malicious software.\n\n        rm -rf $output\n        ;;\n\n    windows-latest)\n        # Windows doesn't have zip?!\n        # TODO: can we use `7z a`?\n        ;;\n\n    *)\n        echo \"Wat? os = $os\";\n        exit 1;\nesac\n\n\n# release/deploy_web.sh:\n#!/bin/bash\n\nset -x\nVERSION=dev\n# S3_ROOT=s3://mjk_asdf/abstreet\nS3_ROOT=s3://abstreet\n\nset -e\n\ncd web;\n# To quickly deploy just one app, modify APPS in the Makefile\nmake release\naws s3 sync build/dist/ $S3_ROOT/$VERSION/\n\n# Set the content type for .wasm files, to speed up how browsers load them\naws s3 cp \\\n       $S3_ROOT/$VERSION \\\n       $S3_ROOT/$VERSION \\\n       --exclude '*' \\\n       --include '*.wasm' \\\n       --no-guess-mime-type \\\n       --content-type=\"application/wasm\" \\\n       --metadata-directive=\"REPLACE\" \\\n       --recursive\n\necho \"Have the appropriate amount of fun: http://abstreet.s3-website.us-east-2.amazonaws.com/$VERSION\"\n\n\n# release/finalize.sh:\n#!/bin/bash\n# Run from ~/Downloads. Work around Github Actions annoyances.\n\nset -e\n\nVERSION=$1\nif [ \"$VERSION\" == \"\" ]; then\n\techo You forgot to pass version\n\texit 1\nfi\n\necho y | unzip abst_linux.zip\nunzip abst_linux.zip\nrm -f abst_linux.zip\nmv abst_linux abstreet_linux_$VERSION\n\necho y | unzip abst_mac.zip\nunzip abst_mac.zip\nrm -f abst_mac.zip\nmv abst_mac abstreet_mac_$VERSION\n\nmkdir abstreet_windows_$VERSION\ncd abstreet_windows_$VERSION\nunzip ../abst_windows.zip\ncd ..\nrm -f abst_windows.zip\n\nzip -r abstreet_linux_$VERSION abstreet_linux_$VERSION\nzip -r abstreet_mac_$VERSION abstreet_mac_$VERSION\nzip -r abstreet_windows_$VERSION abstreet_windows_$VERSION\n\n\n# collisions/Cargo.toml:\n[package]\nname = \"collisions\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[dependencies]\ngeom = { workspace = true }\nkml = { path = \"../kml\" }\nlog = { workspace = true }\nserde = { workspace = true, features=[\"derive\"] }\n\n\n# cli/Cargo.toml:\n[package]\nname = \"cli\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\nconvert_osm = { path = \"../convert_osm\" }\ncsv = { workspace = true }\nfs-err = { workspace = true }\ngeo = { workspace = true }\ngeom = { workspace = true }\nimporter = { path = \"../importer\" }\nlog = { workspace = true }\nmap_model = { path = \"../map_model\" }\nosmio = \"0.8.1\"\nrand  = \"0.8.3\"\nrand_xorshift = { workspace = true }\nraw_map = { path = \"../raw_map\" }\nserde = { workspace = true, features=[\"derive\"] }\nsim = { path = \"../sim\" }\nsynthpop = { path = \"../synthpop\" }\nstructopt = { workspace = true }\ntokio = { workspace = true }\n\n\n# blockfinding/Cargo.toml:\n[package]\nname = \"blockfinding\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\ngeom = { workspace = true }\nlog = { workspace = true }\nmap_model = { path = \"../map_model\" }\nserde = { workspace = true, features=[\"derive\"] }\n\n\n# synthpop/Cargo.toml:\n[package]\nname = \"synthpop\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\ngeom = { workspace = true }\nlog = { workspace = true }\nmap_model = { path = \"../map_model\" }\nrand = \"0.8.5\"\nrand_xorshift = { workspace = true }\nserde = { workspace = true, features=[\"derive\"] }\n\n\n# kml/Cargo.toml:\n[package]\nname = \"kml\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\ncsv = { workspace = true }\ngeom = { workspace = true }\nlog = { workspace = true }\nroxmltree = { version = \"0.19.0\", features=[\"std\"] }\nserde = { workspace = true, features=[\"derive\"] }\n\n\n# import.sh:\n#!/bin/bash\n\n# If true, display importer progress from the Timer (dumped to STDOUT) in one\n# pane, and all logs (on STDERR) in another. This is disabled by default until\n# some issues with multitail are fixed:\n#\n# 1) Automatically exit when the importer is done\n# 2) Stop having part of the logs blink\n# 3) Get the \\r / clear-line thing working for the Timer\nUSE_MULTITAIL=false\n\nSPEED=--release\nif [ \"$1\" == \"--dev\" ]; then\n\tshift\n\tSPEED=\nfi\n\nif ! command -v multitail &> /dev/null; then\n\tUSE_MULTITAIL=false\nfi\n\nif $USE_MULTITAIL; then\n\tRUST_BACKTRACE=1 RUST_LOG_STYLE=always cargo run --bin cli $SPEED --features importer/scenarios -- import $@ > /tmp/abst_stdout 2> /tmp/abst_stderr &\n\tmultitail /tmp/abst_stdout -cT ANSI /tmp/abst_stderr\nelse\n\tRUST_BACKTRACE=1 cargo run --bin cli $SPEED --features importer/scenarios -- import $@\nfi\n\n\n# popgetter/Cargo.toml:\n[package]\nname = \"popgetter\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nanyhow = { workspace = true }\nfs-err = { workspace = true }\ngeo = { workspace = true }\ngeo-types = \"0.7.12\"\ngeojson = { workspace = true }\nserde = { workspace = true, features=[\"derive\"] }\ntopojson = { git = \"https://github.com/georust/topojson\" }\n\n\n# cloud/gather_output.sh:\n#!/bin/bash\n# This script grabs all files changed by VMs, copying them locally.\n#\n# This process is only runnable by Dustin, due to current S3 permissions.\n#\n# Run from the repo's root dir: cloud/gather_output.sh\n\nset -e\nset -x\n\nEXPERIMENT_TAG=$1\nif [ \"$EXPERIMENT_TAG\" == \"\" ]; then\n\techo Missing args;\n\texit 1;\nfi\n\naws s3 cp --recursive s3://abstreet/$EXPERIMENT_TAG/data/ data/\n# gunzip all of the changed files, overwriting the local copies\nfind data/ -path data/system/assets -prune -o -name '*.gz' -print -exec gunzip -f '{}' ';'\n\necho \"Done! Validate the files, run 'updater upload' as usual, and don't forget to clean up s3://abstreet/$EXPERIMENT_TAG\"\n\n\n# cloud/start_batch_import.sh:\n#!/bin/bash\n# This script packages up the importer as it exists in the current git repo,\n# creates a bunch of GCE VMs, and runs the importer there on all cities, using\n# static sharding.\n#\n# This process is only runnable by Dustin, due to current GCE/S3 permissions.\n#\n# Run from the repo's root dir: cloud/start_batch_import.sh\n\nset -e\nset -x\n\nEXPERIMENT_TAG=$1\nif [ \"$EXPERIMENT_TAG\" == \"\" ]; then\n\techo Missing args;\n\texit 1;\nfi\n\nif [ \"$2\" != \"gcs_sync_done\" ]; then\n\techo First go sync dev/data/input from S3 to GCS. https://console.cloud.google.com/transfer/cloud/jobs\n\texit 1;\nfi\n\nNUM_WORKERS=10\nZONE=us-east1-b\n# See other options: https://cloud.google.com/compute/docs/machine-types\n# Particularly... e2-standard-2, n2-standard-2, c2-standard-4\nSMALL_MACHINE_TYPE=e2-standard-2\nLARGE_MACHINE_TYPE=c2-standard-4\n# All of data/ is currently around 30GB\nDISK_SIZE=40GB\n# Compressing and checksumming gigantic files needs more IOPS\n# TODO But wait, e2-standard-2 doesn't support local PD?!\nDISK_TYPE=pd-ssd\n# Haha, using a project from college, my last traffic sim...\nPROJECT=aorta-routes\n\nfunction build_payload {\n\t# It's a faster workflow to copy the local binaries into the VMs, rather than\n\t# build them there.\n\tcargo build --release --bin updater -- download\n\t# This is needed to regenerate popdat.bin for Seattle. It requires the\n\t# VMs to have a matching GDAL version. Since the VM runs the same\n\t# version of Ubuntu as I do locally, this works out fine.\n\tcargo build --release --bin cli --features importer/scenarios\n\n\t# Build our payload for the VMs\n\t# This mkdir deliberately fails if the directory is already there; it probably\n\t# means the last run broke somehow\n\tmkdir worker_payload\n\tmkdir -p worker_payload/target/release\n\tcp target/release/cli worker_payload/target/release/cli\n\tcp target/release/updater worker_payload/target/release/\n\tmkdir worker_payload/data\n\tcp data/MANIFEST.json worker_payload/data\n\tmkdir worker_payload/importer\n\tcp -Rv importer/config worker_payload/importer\n\tcp cloud/worker_script.sh worker_payload/\n\t# Copy in AWS credentials! Obviously don't go making worker_payload/ public or\n\t# letting anybody into the VMs.\n\t#\n\t# Alternatively, I could just scp the files from the VMs back to my local\n\t# computer. But more than likely, GCE's upstream speed to S3 (even\n\t# cross-region) is better than Comcast. :)\n\tcp -Rv ~/.aws worker_payload/\n\tzip -r worker_payload worker_payload\n}\n\nfunction create_vms {\n\t# Ideally we'd use the bulk API, but someone's not on top of those\n\t# gcloud integration tests...\n\t# https://issuetracker.google.com/issues/188462253\n\tfor ((i = 0; i < $NUM_WORKERS; i++)); do\n\t\t# The first shard always handles Seattle, which needs more than\n\t\t# 8GB of memory. Just give it really hefty hardware.\n\t\tif [ $i == 0 ]; then\n\t\t\tmachine_type=$LARGE_MACHINE_TYPE;\n\t\telse\n\t\t\tmachine_type=$SMALL_MACHINE_TYPE;\n\t\tfi\n\n\t\tgcloud compute \\\n\t\t\t--project=$PROJECT \\\n\t\t\tinstances create \"worker-$i\" \\\n\t\t\t--zone=$ZONE \\\n\t\t\t--machine-type=$machine_type \\\n\t\t\t--boot-disk-size=$DISK_SIZE \\\n\t\t\t--boot-disk-type=$DISK_TYPE \\\n\t\t\t--image-family=ubuntu-2004-lts \\\n\t\t\t--image-project=ubuntu-os-cloud \\\n\t\t\t--scopes=compute-rw,storage-ro\n\tdone\n\n\t# There's a funny history behind the whole \"how do I wait for my VM to be\n\t# SSHable?\" question...\n\tsleep 30s\n}\n\nfunction start_workers {\n\tfor ((i = 0; i < $NUM_WORKERS; i++)); do\n\t\tgcloud compute scp \\\n\t\t\t--project=$PROJECT \\\n\t\t\t--zone=$ZONE \\\n\t\t\tworker_payload.zip \\\n\t\t\tworker-$i:~/worker_payload.zip\n\t\tgcloud compute ssh \\\n\t\t\t--project=$PROJECT \\\n\t\t\t--zone=$ZONE \\\n\t\t\tworker-$i \\\n\t\t\t--command=\"sudo apt-get -qq install -y unzip; unzip -q worker_payload.zip; ./worker_payload/worker_script.sh $EXPERIMENT_TAG $i $NUM_WORKERS 1> logs 2>&1 &\"\n\tdone\n}\n\nbuild_payload\ncreate_vms\nstart_workers\n\n# To follow along with a worker:\n# > gcloud compute ssh worker-5 --command='tail -f logs'\n#\n# To see which workers are still running (or have failed):\n# > gcloud compute instances list\n\n\n# cloud/worker_script.sh:\n#!/bin/bash\n# This script runs inside of GCE VMs created by start_batch_import.sh. It\n# imports a bunch of cities, then uploads the results to a temporary\n# subdirectory in S3.\n\nset -e\nset -x\n\nEXPERIMENT_TAG=$1\nWORKER_NUM=$2\nNUM_WORKERS=$3\n\nif [ \"$EXPERIMENT_TAG\" == \"\" ] || [ \"$WORKER_NUM\" == \"\" ] || [ \"$NUM_WORKERS\" == \"\" ]; then\n\techo Missing args;\n\texit 1;\nfi\n\n# Install the AWS CLI\ncurl \"https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\" -o \"awscliv2.zip\"\nunzip awscliv2.zip\nsudo ./aws/install\n\ncd worker_payload\n# Put the credentials in the right place\nmv .aws ~/\n\n# If we import without raw files, we'd wind up downloading fresh OSM data!\n# Reuse what's in S3. But having a bunch of GCE VMs grab from S3 is expensive,\n# so instead, sync from the GCS mirror that I manually update before each job.\ngsutil -m cp -r gs://abstreet-importer/ .\nmv abstreet-importer/dev/data/input data/input\nrm -rf abstreet-importer\nfind data/input -name '*.gz' -print -exec gunzip '{}' ';'\n\n# Install GDAL\nsudo apt-get update\nsudo apt-get install -y libgdal-dev\n\n# Now do the big import!\nrm -fv data/input/us/seattle/raw_maps/huge_seattle.bin data/input/us/seattle/popdat.bin\n./target/release/cli regenerate-everything --shard-num=$WORKER_NUM --num-shards=$NUM_WORKERS\n\n# Upload the results\n./target/release/updater incremental-upload --version=$EXPERIMENT_TAG\n\n# Indicate this VM is done by deleting ourselves. We can't use suspend or stop\n# with a local SSD, so just nuke ourselves instead.\nZONE=$(curl -H Metadata-Flavor:Google http://metadata.google.internal/computeMetadata/v1/instance/zone -s | cut -d/ -f4)\necho y | gcloud compute instances delete $HOSTNAME --zone=$ZONE\n\n\n# headless/Cargo.toml:\n[package]\nname = \"headless\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\ngeojson = { workspace = true }\ngeom = { workspace = true }\nhyper = { version = \"0.14.26\", features = [\"full\"] }\nlazy_static = \"1.4.0\"\nlog = { workspace = true }\nmap_model = { path = \"../map_model\" }\nrand = { workspace = true }\nrand_xorshift = { workspace = true }\nserde = { workspace = true, features=[\"derive\"] }\nserde_json = { workspace = true }\nsim = { path = \"../sim\" }\nsynthpop = { path = \"../synthpop\" }\nstructopt = { workspace = true }\ntokio = { workspace = true }\nurl = \"2.5.0\"\n\n\n# popdat/Cargo.toml:\n[package]\nname = \"popdat\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\nflatgeobuf = { version = \"3.25.0\" }\nfutures = { workspace = true }\ngeo = { workspace = true }\ngeojson = { workspace = true }\ngeom = { workspace = true }\ngeozero = \"0.9.9\"\nlog = { workspace = true }\nmap_model = { path = \"../map_model\" }\nrand = { workspace = true }\nrand_distr = \"0.4.3\"\nrand_xorshift = { workspace = true }\nserde = { workspace = true, features=[\"derive\"] }\nserde_json = { workspace = true }\nsim = { path = \"../sim\" }\nsynthpop = { path = \"../synthpop\" }\n\n\n# popdat/scripts/build_population_areas.sh:\n#!/bin/bash -e\n\n# Outputs a FlatGeoBuf of geometries and their corresponding population,\n# suitable for use in the popdat crate.\n#\n# You'll need to update the `configuration` section to get this to work on your\n# machine.\n# \n# Note: I've only ever used this for US data, with \"Census Blocks\" as areas. In\n# theory other countries could also massage their data to fit into the combined\n# FlatGeoBuf.\n#\n# ## Input\n#\n# I wasn't able to find a reasonable solution using the official census.gov\n# files or API's. Instead I batch-downloaded all the census blocks and their\n# populations from the very nice nhgis.org\n#\n# Specifically, at the time of writing the steps were:\n#   - create an account for nhgis.org and log in\n#   - select \"Get Data\"\n#   - Under \"Apply Filters\": \n#     - Geographic Level: choose \"Block\", then \"submit\"\n#     - Years: \"2010\" (hopefully 2020 will be available before long)\n#     - Topics: choose \"General: Total Population\", then \"submit\"\n#   - Under \"Select Data\":\n#     - Select \"Total Population\"\n#   - Click \"Continue\" towards top right\n#   - Click \"Continue\" again towards top right\n#   - Source Tables:\n#     - You should see that you've selected \"1 source table\" \n#       - This corresponds to a CSV file of the populations and GISJOIN id but\n#         no geometries \n#     - Click \"Geographic Extents\" > \"Select All\" > Submit\n#       - This corresponds to shapefiles for every state + DC + Puerto Rico\n#         with a GISJOIN attribute to join to the population CSV\n#   - Enter a \"Description\" which is memorable to you like (2010 all US block populations)\n#   - Submit and wait for the batch to be prepared\n#\n# Input files:\n# - a csv of populations with a GISJOIN field\n# - geometry shapefiles with the area boundaries and a GISJOIN field\n# \n# Output:\n# An single FGB with a feature for each area which includes its population.\n\n# Configuration\n\n## Inputs\n\ngeometry_shapefiles=$(ls source/nhgis_us_block_population/*.shp)\npopulation_csv=source/nhgis_us_block_population/nhgis0004_ds172_2010_block.csv\npopulation_column_name=H7V001\n\n# ## SpatiaLite\n#\n# Even though we're not doing spatial changes in sqlite, making *any* changes\n# to spatial tables, fires db triggers, which require you have the spatialite\n# lib linked.\nspatialite_bin=/usr/local/Cellar/sqlite/3.34.0/bin/sqlite3 \nspatialite_lib=/usr/local/lib/mod_spatialite.dylib\n\n# Main program follows\n\ngpkg_output=generated/population_areas.gpkg\n\nrm -f $gpkg_output\n\necho \"Importing geometries - start $(date)\"\n\nfor i in $geometry_shapefiles; do\n    filename=$(basename -- \"$i\")\n    extension=\"${filename##*.}\"\n    layer_name=\"${filename%.*}\"\n    if [ ! -f \"$gpkg_output\" ]; then\n\t\techo \"starting with $i\"\n        # first file - create the consolidated output file\n\n        # I tried selecting only the columns we needed here, but I got a \"table\n        # not found\" error, so instead we filter later when building the FGB\n        # ogr2ogr -f \"GPKG\" -nln areas -t_srs \"WGS84\" -dialect SQLite -sql \"SELECT GISJOIN FROM $layer_name\" $gpkg_output $i\n\n        # Note the `nlt` option addresses this warning:\n        # > Warning 1: A geometry of type MULTIPOLYGON is inserted into layer areas of geometry type POLYGON, which is not normally allowed by the GeoPackage specification, but the driver will however do it. To create a conformant GeoPackage, if using ogr2ogr, the -nlt option can be used to override the layer geometry type. This warning will no longer be emitted for this combination of layer and feature geometry type.\n        ogr2ogr -f \"GPKG\" -nlt MULTIPOLYGON -nln areas -t_srs \"WGS84\" $gpkg_output $i\n    else\n\t\techo \"merging $i\"\n        # update the output file with new file content\n        #ogr2ogr -f \"GPKG\" -nln areas -t_srs \"WGS84\" -dialect SQLite -sql \"SELECT GISJOIN FROM $layer_name\" -update -append $gpkg_output $i\n        ogr2ogr -f \"GPKG\" -nlt MULTIPOLYGON -nln areas -t_srs \"WGS84\" -update -append $gpkg_output $i\n    fi\ndone\n\necho \"### Indexing geometries - start $(date)\"\necho \"\nPRAGMA journal_mode = off;\nCREATE INDEX index_areas_on_gisjoin on areas(GISJOIN)\n\" | $spatialite_bin $gpkg_output\n\necho \"## Importing and indexing populations data - start $(date)\"\n\necho \"\nPRAGMA journal_mode = off;\nDROP TABLE IF EXISTS populations;\n.import --csv $population_csv populations\nALTER TABLE populations RENAME COLUMN $population_column_name TO population;\nCREATE INDEX index_populations_on_GISJOIN ON populations(GISJOIN);\n\" | $spatialite_bin $gpkg_output\n\necho \"## join populations and geometries - start $(date)\"\n\necho \"\nPRAGMA journal_mode = off;\n.load $spatialite_lib\nALTER TABLE areas ADD COLUMN population;\nupdate areas set population=(select population from populations where populations.GISJOIN=areas.GISJOIN);\n\" | $spatialite_bin $gpkg_output\n\necho \"## outputting fgb - start $(date)\"\n\nogr2ogr generated/population_areas.fgb $gpkg_output -dialect SQLite -sql \"SELECT geom, population, GISJOIN FROM areas\"\n\necho \"## Done - $(date)\"\n\n\n\n# popdat/src/lib.rs:\n//! popdat (\"population data\") generates `Scenarios` given a map and some external census data.\n//! Some of this functionality should maybe be reorganized or incorporated into the importer crate,\n//! but for now, it's convenient to organize it here.\n//!\n//! All of the types and methods here are tied to a single `Map`. Even if a city is chopped up into\n//! multiple pieces, for now, let's assume we're just dealing with one map at a time. That lets us\n//! use the map's coordinate system, building IDs, etc.\n//!\n//! These types form a pipeline:\n//!\n//! 1) For a given map, find some census data that describes how many people live in different\n//!    areas of the city. (CensusArea)\n//! 2) Take the CensusAreas and turn them into individual CensusPersons, by randomly choosing a\n//!    specific building on the map as their home, and assigning specific attributes based on the\n//!    census data's distribution.\n//! 3) For each CensusPerson, classify them into a PersonType, then generate a Schedule of\n//!    different Activities throughout the day.\n//! 4) Pick specific buildings to visit to satisfy the Schedule.\n\n#[macro_use]\nextern crate anyhow;\n#[macro_use]\nextern crate log;\n\nuse rand_xorshift::XorShiftRng;\n\nuse abstutil::Timer;\nuse geom::{Distance, Time};\nuse map_model::{BuildingID, Map};\nuse synthpop::Scenario;\n\npub use self::distribute_people::distribute_population_to_homes;\n\nmod activities;\nmod distribute_people;\nmod import_census;\nmod make_person;\npub mod od;\n\n/// Represents aggregate demographic data for some part of a city. These could be census tracts or\n/// blocks, depending what data we find. All of the areas should roughly partition the map -- we\n/// probably don't need to guarantee we cover every single building, but we definitely shouldn't\n/// have two overlapping areas.\n#[derive(Debug, PartialEq)]\npub struct CensusArea {\n    pub polygon: geo::Polygon,\n    pub population: usize,\n    // TODO Not sure what goes here, whatever census data actually has that could be useful\n}\n\n/// Demographic information for a single person\npub struct CensusPerson {\n    pub home: BuildingID,\n    pub age: usize,\n    pub employed: bool,\n    pub owns_car: bool,\n}\n\n/// It might be useful to classify a CensusPerson into different categories to figure out their\n/// Schedule.\npub enum PersonType {\n    Student,\n    Worker,\n}\n\n/// A single person's daily schedule. It's assumed that someone always starts at home. And for most\n/// people, the last entry should probably be Activity::Home.\npub struct Schedule {\n    pub activities: Vec<(Time, Activity)>,\n}\n\n/// Different things people might do in the day. Maybe it's more clear to call this a\n/// DestinationType or similar.\n#[derive(Hash, PartialEq, Eq, Clone, Copy, Debug)]\npub enum Activity {\n    Breakfast,\n    Lunch,\n    Dinner,\n    School,\n    Entertainment,\n    Errands,\n    Financial,\n    Healthcare,\n    Home,\n    Work,\n}\n\n/// Any arbitrarily chosen parameters needed should be put here, so they can be controlled from the\n/// UI or tuned for different cities.\npub struct Config {\n    pub walk_for_distances_shorter_than: Distance,\n    pub walk_or_bike_for_distances_shorter_than: Distance,\n}\n\nimpl Config {\n    pub fn default() -> Config {\n        Config {\n            walk_for_distances_shorter_than: Distance::miles(0.5),\n            walk_or_bike_for_distances_shorter_than: Distance::miles(3.0),\n        }\n    }\n}\n\n/// Wires together all the pieces, so you can just hand this any map, and it'll automatically find\n/// appropriate census data, and use it to produce a Scenario.\npub fn generate_scenario(\n    scenario_name: &str,\n    areas: Vec<CensusArea>,\n    config: Config,\n    map: &Map,\n    rng: &mut XorShiftRng,\n) -> Scenario {\n    let mut timer = Timer::new(\"building scenario\");\n\n    // find_data_for_map may return an error. If so, just plumb it back to the caller using the ?\n    // operator\n    timer.start(\"assigning people to houses\");\n    let people = distribute_people::assign_people_to_houses(areas, map, rng, &config);\n    timer.stop(\"assigning people to houses\");\n\n    let mut scenario = Scenario::empty(map, scenario_name);\n    timer.start(\"building people\");\n    scenario.people.extend(make_person::make_people(\n        people, map, &mut timer, rng, &config,\n    ));\n    timer.stop(\"building people\");\n\n    timer.start(\"removing weird schedules\");\n    scenario = scenario.remove_weird_schedules(true);\n    timer.stop(\"removing weird schedules\");\n\n    scenario\n}\n\n\n# sim/Cargo.toml:\n[package]\nname = \"sim\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\nctrlc = { version = \"3.4.1\", optional = true }\ndowncast-rs = \"1.2.0\"\nenum_dispatch = \"0.3.12\"\ngeom = { workspace = true }\ninstant = { workspace = true }\nlibm = \"0.2.8\"\nlog = { workspace = true }\nmap_model = { path = \"../map_model\" }\nrand = { workspace = true }\nrand_distr = \"0.4.3\"\nrand_xorshift = { workspace = true }\nserde = { workspace = true, features=[\"derive\"] }\nstructopt = { workspace = true }\nsynthpop = { path = \"../synthpop\" }\n\n[[bin]]\nname = \"run_scenario\"\nrequired-features = [\"ctrlc\"]\n\n\n# apps/map_editor/Cargo.toml:\n[package]\nname = \"map_editor\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\", \"lib\"]\n\n[features]\ndefault = [\"widgetry/native-backend\"]\nwasm = [\"getrandom/js\", \"wasm-bindgen\", \"widgetry/wasm-backend\"]\n\n[dependencies]\nabstio = { path = \"../../abstio\" }\nabstutil = { path = \"../../abstutil\" }\nfs-err = { workspace = true }\ngeom = { workspace = true }\ngetrandom = { workspace = true, optional = true }\nlog = { workspace = true }\nraw_map = { path = \"../../raw_map\" }\nserde = { workspace = true, features=[\"derive\"] }\nosm2streets = { git = \"https://github.com/a-b-street/osm2streets\" }\nstructopt = { workspace = true }\nwasm-bindgen = { workspace = true, optional = true }\nwidgetry = { path = \"../../widgetry\" }\n\n\n# apps/fifteen_min/Cargo.toml:\n[package]\nname = \"fifteen_min\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\", \"lib\"]\n\n[features]\ndefault = [\"map_gui/native\", \"widgetry/native-backend\"]\nwasm = [\"getrandom/js\", \"map_gui/wasm\", \"wasm-bindgen\", \"widgetry/wasm-backend\"]\n\n[dependencies]\nabstio = { path = \"../../abstio\" }\nabstutil = { path = \"../../abstutil\" }\ncontour = { workspace = true }\ngeojson = { workspace = true }\ngeom = { workspace = true }\ngetrandom = { workspace = true, optional = true }\nlog = { workspace = true }\nmap_gui = { path = \"../../map_gui\" }\nmap_model = { path = \"../../map_model\" }\nstructopt = { workspace = true }\nsynthpop = { path = \"../../synthpop\" }  # TODO Remove\nwasm-bindgen = { workspace = true, optional = true }\nwidgetry = { path = \"../../widgetry\" }\n\n\n# apps/fifteen_min/src/lib.rs:\n#![allow(clippy::type_complexity)]\n\nuse structopt::StructOpt;\n\nuse widgetry::Settings;\n\n#[macro_use]\nextern crate log;\n\nmod amenities_details;\nmod bus;\nmod common;\nmod from_amenity;\nmod isochrone;\nmod render;\nmod score_homes;\nmod single_start;\n\ntype App = map_gui::SimpleApp<crate::isochrone::Options>;\n\npub fn main() {\n    let settings = Settings::new(\"15-minute neighborhoods\");\n    run(settings);\n}\n\nfn run(mut settings: Settings) {\n    let mut options = map_gui::options::Options::load_or_default();\n    let args = map_gui::SimpleAppArgs::from_iter(abstutil::cli_args());\n    args.override_options(&mut options);\n\n    settings = args\n        .update_widgetry_settings(settings)\n        .canvas_settings(options.canvas_settings.clone());\n\n    let session = crate::isochrone::Options {\n        movement: crate::isochrone::MovementOptions::Walking(\n            map_model::connectivity::WalkingOptions::default(),\n        ),\n        thresholds: crate::isochrone::Options::default_thresholds(),\n    };\n\n    widgetry::run(settings, |ctx| {\n        map_gui::SimpleApp::new(\n            ctx,\n            options,\n            Some(args.map_name()),\n            args.cam,\n            session,\n            |ctx, app| vec![single_start::SingleStart::random_start(ctx, app)],\n        )\n    });\n}\n\n#[cfg(target_arch = \"wasm32\")]\nuse wasm_bindgen::prelude::*;\n\n#[cfg(target_arch = \"wasm32\")]\n#[wasm_bindgen(js_name = \"run\")]\npub fn run_wasm(root_dom_id: String, assets_base_url: String, assets_are_gzipped: bool) {\n    let settings = Settings::new(\"15-minute neighborhoods\")\n        .root_dom_element_id(root_dom_id)\n        .assets_base_url(assets_base_url)\n        .assets_are_gzipped(assets_are_gzipped);\n\n    run(settings);\n}\n\n\n# apps/game/Cargo.toml:\n[package]\nname = \"game\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\ndescription = \"A traffic simulation game based on OpenStreetMap\"\nrepository = \"https://github.com/a-b-street/abstreet\"\nlicense = \"Apache-2.0\"\n\n[lib]\ncrate-type = [\"cdylib\", \"lib\"]\n\n[features]\ndefault = [\"map_gui/native\", \"widgetry/native-backend\"]\nwasm = [\"getrandom/js\", \"map_gui/wasm\", \"wasm-bindgen\", \"widgetry/wasm-backend\"]\n\n[dependencies]\nabstio = { path = \"../../abstio\" }\nabstutil = { path = \"../../abstutil\" }\nanyhow = { workspace = true }\nblockfinding = { path = \"../../blockfinding\" }\ncollisions = { path = \"../../collisions\" }\ncolorous = { workspace = true }\ncontour = { workspace = true }\ncsv = { workspace = true }\ndowncast-rs = \"1.2.0\"\nenumset = \"1.1.3\"\nfs-err = { workspace = true }\nfutures-channel = { workspace = true }\ngeo = { workspace = true }\ngeojson = { workspace = true }\ngeom = { workspace = true }\ngetrandom = { workspace = true, optional = true }\ninstant = { workspace = true }\nkml = { path = \"../../kml\" }\nlazy_static = \"1.4.0\"\nlog = { workspace = true }\nlttb = \"0.2.0\"\nmaplit = \"1.0.2\"\nmap_gui = { path = \"../../map_gui\" }\nmap_model = { path = \"../../map_model\" }\npetname = \"1.1.3\"\npopdat = { path = \"../../popdat\" }\nrand = { workspace = true }\nrand_xorshift = { workspace = true }\nserde = { workspace = true, features=[\"derive\"] }\nserde_json = { workspace = true }\nsvg_face = \"0.1.3\"\nsim = { path = \"../../sim\" }\nsynthpop = { path = \"../../synthpop\" }\nstructopt = { workspace = true }\nwasm-bindgen = { workspace = true, optional = true }\nwidgetry = { path = \"../../widgetry\" }\n\n\n# apps/santa/Cargo.toml:\n[package]\nname = \"santa\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\", \"lib\"]\n\n[features]\ndefault = [\"map_gui/native\", \"widgetry/native-backend\"]\nwasm = [\"getrandom/js\", \"map_gui/wasm\", \"wasm-bindgen\", \"widgetry/wasm-backend\"]\n\n[dependencies]\nabstio = { path = \"../../abstio\" }\nabstutil = { path = \"../../abstutil\" }\nanyhow = { workspace = true }\ngeom = { workspace = true }\ngetrandom = { workspace = true, optional = true }\nkml = { path = \"../../kml\" }\nlog = { workspace = true }\nmap_gui = { path = \"../../map_gui\" }\nmap_model = { path = \"../../map_model\" }\nrand = { workspace = true }\nrand_xorshift = { workspace = true }\nrodio = { version = \"0.17.3\", default-features = false, features = [\"vorbis\"] }\nserde = { workspace = true, features=[\"derive\"] }\nwasm-bindgen = { workspace = true, optional = true }\nwidgetry = { path = \"../../widgetry\" }\n\n\n# apps/ltn/Cargo.toml:\n[package]\nname = \"ltn\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\", \"lib\"]\n\n[features]\ndefault = [\"home\", \"map_gui/native\", \"widgetry/native-backend\"]\nwasm = [\"getrandom/js\", \"map_gui/wasm\", \"wasm-bindgen\", \"widgetry/wasm-backend\"]\n\n[dependencies]\nabstio = { path = \"../../abstio\" }\nabstutil = { path = \"../../abstutil\" }\nanyhow = { workspace = true }\nblockfinding = { path = \"../../blockfinding\" }\ncontour = { workspace = true }\ncsv = { workspace = true }\nflate2 = { workspace = true }\nfutures-channel = { workspace = true }\ngeo = { workspace = true }\ngeojson = { workspace = true }\ngeom = { workspace = true }\ngetrandom = { workspace = true, optional = true }\nhome = { version = \"0.5.5\", optional = true }\nlazy_static = \"1.4.0\"\nlog = { workspace = true }\nmaplit = \"1.0.2\"\nmap_gui = { path = \"../../map_gui\" }\nmap_model = { path = \"../../map_model\" }\nmd5 = \"0.7.0\"\nrand = { workspace = true }\nrand_xorshift = { workspace = true }\nregex = \"1.8.1\"\nserde = { workspace = true, features=[\"derive\"] }\nserde_json = { workspace = true }\nosm2streets = { git = \"https://github.com/a-b-street/osm2streets\" }\nsynthpop = { path = \"../../synthpop\" }\nwasm-bindgen = { workspace = true, optional = true }\nwidgetry = { path = \"../../widgetry\" }\nstructopt = { workspace = true }\n\n[dev-dependencies]\ntests = { path = \"../../tests\" }\nfs-err = { workspace = true }\n\n\n# apps/osm_viewer/Cargo.toml:\n[package]\nname = \"osm_viewer\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\", \"lib\"]\n\n[features]\ndefault = [\"map_gui/native\", \"widgetry/native-backend\"]\nwasm = [\"getrandom/js\", \"map_gui/wasm\", \"wasm-bindgen\", \"widgetry/wasm-backend\"]\n\n[dependencies]\nabstio = { path = \"../../abstio\" }\nabstutil = { path = \"../../abstutil\" }\ngeom = { workspace = true }\ngetrandom = { workspace = true, optional = true }\nmap_gui = { path = \"../../map_gui\" }\nmap_model = { path = \"../../map_model\" }\nstructopt = { workspace = true }\nwasm-bindgen = { workspace = true, optional = true }\nwidgetry = { path = \"../../widgetry\" }\n\n\n# apps/osm_viewer/src/lib.rs:\nmod viewer;\n\nuse structopt::StructOpt;\n\nuse widgetry::Settings;\n\npub fn main() {\n    let settings = Settings::new(\"OpenStreetMap viewer\");\n    run(settings)\n}\n\npub fn run(mut settings: Settings) {\n    let mut opts = map_gui::options::Options::load_or_default();\n    opts.show_building_driveways = false;\n    let args = map_gui::SimpleAppArgs::from_iter(abstutil::cli_args());\n    args.override_options(&mut opts);\n\n    settings = args\n        .update_widgetry_settings(settings)\n        .canvas_settings(opts.canvas_settings.clone());\n    widgetry::run(settings, |ctx| {\n        map_gui::SimpleApp::new(\n            ctx,\n            opts,\n            Some(args.map_name()),\n            args.cam,\n            (),\n            |ctx, app| vec![viewer::Viewer::new_state(ctx, app)],\n        )\n    });\n}\n\n#[cfg(target_arch = \"wasm32\")]\nuse wasm_bindgen::prelude::*;\n\n#[cfg(target_arch = \"wasm32\")]\n#[wasm_bindgen(js_name = \"run\")]\npub fn run_wasm(root_dom_id: String, assets_base_url: String, assets_are_gzipped: bool) {\n    let settings = Settings::new(\"OpenStreetMap viewer\")\n        .root_dom_element_id(root_dom_id)\n        .assets_base_url(assets_base_url)\n        .assets_are_gzipped(assets_are_gzipped);\n\n    run(settings);\n}\n\n\n# apps/parking_mapper/Cargo.toml:\n[package]\nname = \"parking_mapper\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[features]\ndefault = [\"map_gui/native\", \"reqwest\", \"widgetry/native-backend\"]\n\n[dependencies]\nabstio = { path = \"../../abstio\" }\nabstutil = { path = \"../../abstutil\" }\nanyhow = { workspace = true }\nfs-err = { workspace = true }\ngeom = { workspace = true }\nlog = { workspace = true }\nmap_gui = { path = \"../../map_gui\" }\nmap_model = { path = \"../../map_model\" }\nreqwest = { version = \"0.11.17\", optional = true, default-features=false, features=[\"blocking\", \"rustls-tls\"] }\nstructopt = { workspace = true }\nwidgetry = { path = \"../../widgetry\" }\nxmltree = \"0.10.1\"\n\n\n# apps/parking_mapper/src/main.rs:\n#[macro_use]\nextern crate log;\n\nuse structopt::StructOpt;\n\nmod mapper;\n\nfn main() {\n    let mut options = map_gui::options::Options::load_or_default();\n    options.canvas_settings.min_zoom_for_detail = 2.0;\n    let args = map_gui::SimpleAppArgs::from_iter(abstutil::cli_args());\n    args.override_options(&mut options);\n\n    let settings = args\n        .update_widgetry_settings(widgetry::Settings::new(\"OSM parking mapper\"))\n        .canvas_settings(options.canvas_settings.clone());\n    widgetry::run(settings, |ctx| {\n        map_gui::SimpleApp::new(\n            ctx,\n            options,\n            Some(args.map_name()),\n            args.cam,\n            (),\n            |ctx, app| vec![mapper::ParkingMapper::new_state(ctx, app)],\n        )\n    });\n}\n\n\n# widgetry/Cargo.toml:\n[package]\nname = \"widgetry\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[features]\nnative-backend = [\"clipboard\", \"glutin\", \"tokio\"]\nwasm-backend = [\"instant/wasm-bindgen\", \"js-sys\", \"wasm-bindgen\", \"wasm-bindgen-futures\", \"wasm-streams\", \"web-sys\"]\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\nanyhow = { workspace = true }\n# backtrace = \"0.3.40\"\nclipboard = { version = \"0.5.0\", optional = true }\ncolorous = { workspace = true }\ndowncast-rs = \"1.2.0\"\nflate2 = { workspace = true }\nfs-err = { workspace = true }\nfutures = { workspace = true }\nfutures-channel = { workspace = true }\ngeojson = { workspace = true }\ngeom = { workspace = true }\nglow = \"0.12.1\"\nglutin = { git = \"https://github.com/rust-windowing/glutin\", optional = true, rev = \"2bffbf52d6b4f4c32adc463818e10ac8082948e4\" }\nhtmlescape = \"0.3.1\"\nimage = { version = \"0.24.6\", default-features = false, features=[\"gif\", \"png\"] }\ninstant = { workspace = true }\njs-sys = { version = \"0.3.47\", optional = true }\nlog = { workspace = true }\nlru = \"0.10.0\"\nlyon = \"1.0.0\"\nserde = { workspace = true, features=[\"derive\"] }\nserde_json = { workspace = true }\ntaffy = \"0.2.2\"\ntokio = { workspace = true, optional = true }\nttf-parser = \"0.19.0\"\nusvg = \"0.32.0\"\nusvg-text-layout = { version = \"0.32.0\", default-features = false }\nwasm-bindgen = { workspace = true, optional = true }\nwasm-bindgen-futures = { version = \"0.4.34\", optional = true }\nwasm-streams = { version = \"0.3.0\", optional = true }\nwebbrowser = \"0.8.9\"\nwinit = \"0.27.0\"\n\n[dependencies.web-sys]\nworkspace = true\noptional = true\n# TODO Some of these may only be needed in map_gui. It's hard to detangle.\nfeatures = [\n  \"Headers\",\n  \"History\",\n  \"ReadableStream\",\n  \"Request\",\n  \"RequestInit\",\n  \"RequestMode\",\n  \"Response\",\n  \"Window\",\n]\n\n\n# widgetry/src/runner.rs:\nuse std::cell::Cell;\nuse std::panic;\n\nuse image::{GenericImageView, Pixel};\nuse instant::Instant;\nuse winit::window::Icon;\n\nuse abstutil::{elapsed_seconds, Timer};\nuse geom::Duration;\n\nuse crate::app_state::App;\nuse crate::assets::Assets;\nuse crate::tools::screenshot::screenshot_everything;\nuse crate::{\n    Canvas, CanvasSettings, Event, EventCtx, GfxCtx, Prerender, SharedAppState, Style, Text,\n    UpdateType, UserInput,\n};\n\nconst UPDATE_FREQUENCY: std::time::Duration = std::time::Duration::from_millis(1000 / 30);\n// Manually enable and then check STDOUT\nconst DEBUG_PERFORMANCE: bool = false;\n\n// TODO Rename this GUI or something\npub(crate) struct State<A: SharedAppState> {\n    pub(crate) app: App<A>,\n    pub(crate) canvas: Canvas,\n    style: Style,\n\n    focus_owned_by: Option<String>,\n}\n\nimpl<A: 'static + SharedAppState> State<A> {\n    // The bool indicates if the input was actually used.\n    fn event(&mut self, mut ev: Event, prerender: &Prerender) -> (Vec<UpdateType>, bool) {\n        if let Event::MouseWheelScroll(dx, dy) = ev {\n            if self.canvas.settings.invert_scroll {\n                ev = Event::MouseWheelScroll(-dx, -dy);\n            }\n        }\n\n        // Always reset the cursor, unless we're handling an update event. If we're hovering on a\n        // button, we'll discover that by plumbing through the event.\n        if let Event::Update(_) = ev {\n        } else {\n            prerender\n                .inner\n                .set_cursor_icon(if self.canvas.drag_canvas_from.is_some() {\n                    // We haven't run canvas_movement() yet, so we don't know if the button has been\n                    // released. Bit of a hack to check this here, but better behavior.\n                    if matches!(ev, Event::LeftMouseButtonUp { .. }) {\n                        winit::window::CursorIcon::Default\n                    } else {\n                        winit::window::CursorIcon::Grabbing\n                    }\n                } else {\n                    winit::window::CursorIcon::Default\n                });\n        }\n\n        // It's impossible / very unlikely we'll grab the cursor in map space before the very first\n        // start_drawing call.\n        let input = UserInput::new(ev, &self.canvas);\n\n        // Update some widgetry state that's stashed in Canvas for sad reasons.\n        {\n            if let Event::WindowResized(new_size) = input.event {\n                // On platforms like Linux, new_size jumps around when the window is first created.\n                // As a result, if an app has loading screens at startup and doesn't process all of\n                // these events, new_size may be stuck at an incorrect value during the loading.\n                //\n                // Instead, just use inner_size; it appears correct on all platforms tested.\n                let inner_size = prerender.window_size();\n                trace!(\n                    \"winit event says the window was resized from {}, {} to {:?}. But inner size \\\n                     is {:?}, so using that\",\n                    self.canvas.window_width,\n                    self.canvas.window_height,\n                    new_size,\n                    inner_size\n                );\n                prerender.window_resized(inner_size);\n                self.canvas.window_width = inner_size.width;\n                self.canvas.window_height = inner_size.height;\n            }\n\n            if let Event::KeyPress(key) = input.event {\n                self.canvas.keys_held.insert(key);\n            } else if let Event::KeyRelease(key) = input.event {\n                self.canvas.keys_held.remove(&key);\n            }\n\n            if let Some(pt) = input.get_moved_mouse() {\n                self.canvas.cursor = pt;\n            }\n\n            if input.event == Event::WindowGainedCursor {\n                self.canvas.window_has_cursor = true;\n            }\n            if input.window_lost_cursor() {\n                self.canvas.window_has_cursor = false;\n            }\n        }\n\n        match panic::catch_unwind(panic::AssertUnwindSafe(|| {\n            let mut ctx = EventCtx {\n                fake_mouseover: false,\n                input,\n                canvas: &mut self.canvas,\n                prerender,\n                style: &mut self.style,\n                updates_requested: vec![],\n                canvas_movement_called: false,\n\n                focus_owned_by: self.focus_owned_by.take(),\n                // If the widget owning focus doesn't renew it, then it'll expire by the end of\n                // this event.\n                next_focus_owned_by: None,\n            };\n            let started = Instant::now();\n            self.app.event(&mut ctx);\n            self.focus_owned_by = ctx.next_focus_owned_by.take();\n            if DEBUG_PERFORMANCE {\n                println!(\"- event() took {}s\", elapsed_seconds(started));\n            }\n\n            // If the user is dragging the canvas, but then another UI state interrupts things\n            // (like a panel popping up that blocks the canvas) and canvas_movement() isn't called\n            // for this event, then cancel the drag.\n            if ctx.canvas.drag_canvas_from.is_some() && !ctx.canvas_movement_called {\n                ctx.canvas.drag_canvas_from = None;\n                // TODO When the user releases the mouse button, it'll count as\n                // normal_left_click(). An example why this is a bug:\n                //\n                // 1) Start dragging the map in A/B Street's sandbox mode\n                // 2) Press escape, bringing up a menu\n                // 3) Release the mouse while hovering off of the panel\n                // This counts as clicking \"off the panel\" and closes it immediately.\n            }\n\n            // TODO We should always do has_been_consumed, but various hacks prevent this from being\n            // true. For now, just avoid the specific annoying redraw case when a KeyRelease event\n            // is unused.\n            let input_used = match ev {\n                Event::KeyRelease(_) => ctx.input.has_been_consumed(),\n                _ => true,\n            };\n            (ctx.updates_requested, input_used)\n        })) {\n            Ok(pair) => pair,\n            Err(err) => {\n                self.app.shared_app_state.dump_before_abort(&self.canvas);\n                panic::resume_unwind(err);\n            }\n        }\n    }\n\n    /// Returns naming hint. Logically consumes the number of uploads.\n    pub(crate) fn draw(&mut self, prerender: &Prerender, screenshot: bool) -> Option<String> {\n        let mut g = GfxCtx::new(prerender, &self.canvas, &self.style, screenshot);\n\n        self.canvas.start_drawing();\n\n        let started = Instant::now();\n        if let Err(err) = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n            self.app.draw(&mut g);\n        })) {\n            self.app.shared_app_state.dump_before_abort(&self.canvas);\n            panic::resume_unwind(err);\n        }\n        let naming_hint = g.naming_hint.take();\n\n        if DEBUG_PERFORMANCE {\n            println!(\n                \"----- {} uploads, {} draw calls, {} forks. draw() took {} -----\",\n                g.get_num_uploads(),\n                g.num_draw_calls,\n                g.num_forks,\n                elapsed_seconds(started)\n            );\n        }\n\n        prerender.inner.draw_finished(g.inner);\n        naming_hint\n    }\n\n    pub(crate) fn free_memory(&mut self) {\n        self.app.shared_app_state.free_memory();\n    }\n}\n\n/// Customize how widgetry works. Most of these settings can't be changed after starting.\npub struct Settings {\n    pub(crate) window_title: String,\n    #[cfg(target_arch = \"wasm32\")]\n    pub(crate) root_dom_element_id: String,\n    pub(crate) assets_base_url: Option<String>,\n    pub(crate) assets_are_gzipped: bool,\n    dump_raw_events: bool,\n    pub(crate) scale_factor: Option<f64>,\n    require_minimum_width: Option<f64>,\n    window_icon: Option<String>,\n    loading_tips: Option<Text>,\n    load_default_textures: bool,\n    pub(crate) read_svg: Box<dyn Fn(&str) -> Vec<u8>>,\n    pub(crate) canvas_settings: CanvasSettings,\n}\n\nimpl Settings {\n    /// Specify the title of the window to open.\n    pub fn new(window_title: &str) -> Settings {\n        Settings {\n            window_title: window_title.to_string(),\n            #[cfg(target_arch = \"wasm32\")]\n            root_dom_element_id: \"widgetry-canvas\".to_string(),\n            assets_base_url: None,\n            assets_are_gzipped: false,\n            dump_raw_events: false,\n            scale_factor: None,\n            require_minimum_width: None,\n            window_icon: None,\n            loading_tips: None,\n            load_default_textures: true,\n            read_svg: Box::new(|path| {\n                use std::io::Read;\n\n                let mut file =\n                    fs_err::File::open(path).unwrap_or_else(|_| panic!(\"Couldn't read {}\", path));\n                let mut buffer = Vec::new();\n                file.read_to_end(&mut buffer)\n                    .unwrap_or_else(|_| panic!(\"Couldn't read all of {}\", path));\n                buffer\n            }),\n            canvas_settings: CanvasSettings::new(),\n        }\n    }\n\n    /// Log every raw winit event to the DEBUG level.\n    pub fn dump_raw_events(mut self) -> Self {\n        assert!(!self.dump_raw_events);\n        self.dump_raw_events = true;\n        self\n    }\n\n    /// Override the initial HiDPI scale factor from whatever winit initially detects.\n    pub fn scale_factor(mut self, scale_factor: f64) -> Self {\n        self.scale_factor = Some(scale_factor);\n        self\n    }\n\n    #[cfg(target_arch = \"wasm32\")]\n    pub fn root_dom_element_id(mut self, element_id: String) -> Self {\n        self.root_dom_element_id = element_id;\n        self\n    }\n\n    /// If the screen width using the monitor's detected scale factor is below this value (in units\n    /// of logical pixels, not physical), then force the scale factor to be 1. If `scale_factor()`\n    /// has been called, always use that override. This is helpful for users with HiDPI displays at\n    /// low resolutions, for applications designed for screens with some minimum width. Scaling\n    /// down UI elements isn't ideal (since it doesn't respect the user's device settings), but\n    /// having panels overlap is worse.\n    pub fn require_minimum_width(mut self, width: f64) -> Self {\n        self.require_minimum_width = Some(width);\n        self\n    }\n\n    /// Sets the window icon. This should be a 32x32 image.\n    pub fn window_icon(mut self, path: String) -> Self {\n        self.window_icon = Some(path);\n        self\n    }\n\n    /// Sets the text that'll appear during long `ctx.loading_screen` calls. You can use this as a\n    /// way to entertain your users while they're waiting.\n    pub fn loading_tips(mut self, txt: Text) -> Self {\n        self.loading_tips = Some(txt);\n        self\n    }\n\n    /// When calling `Widget::draw_svg`, `ButtonBuilder::image_path`, and similar, use this function\n    /// to transform the filename given to the raw bytes of that SVG file. By default, this just\n    /// reads the file normally. You may want to override this to more conveniently locate the\n    /// file (transforming a short filename to a full path) or to handle reading files in WASM\n    /// (where regular filesystem IO doesn't work).\n    pub fn read_svg(mut self, function: Box<dyn Fn(&str) -> Vec<u8>>) -> Self {\n        self.read_svg = function;\n        self\n    }\n\n    pub fn assets_base_url(mut self, value: String) -> Self {\n        self.assets_base_url = Some(value);\n        self\n    }\n\n    pub fn assets_are_gzipped(mut self, value: bool) -> Self {\n        self.assets_are_gzipped = value;\n        self\n    }\n\n    pub fn canvas_settings(mut self, settings: CanvasSettings) -> Self {\n        self.canvas_settings = settings;\n        self\n    }\n\n    pub fn load_default_textures(mut self, load_default_textures: bool) -> Self {\n        self.load_default_textures = load_default_textures;\n        self\n    }\n}\n\npub fn run<\n    A: 'static + SharedAppState,\n    F: FnOnce(&mut EventCtx) -> (A, Vec<Box<dyn crate::app_state::State<A>>>),\n>(\n    settings: Settings,\n    make_app: F,\n) -> ! {\n    let mut timer = Timer::new(\"setup widgetry\");\n    let (prerender_innards, event_loop) = crate::backend::setup(&settings);\n\n    if let Some(ref path) = settings.window_icon {\n        if !cfg!(target_arch = \"wasm32\") {\n            let image = image::open(path).unwrap();\n            let (width, height) = image.dimensions();\n            let mut rgba = Vec::with_capacity((width * height) as usize * 4);\n            for (_, _, pixel) in image.pixels() {\n                rgba.extend_from_slice(&pixel.to_rgba().0);\n            }\n            let icon = Icon::from_rgba(rgba, width, height).unwrap();\n            prerender_innards.set_window_icon(icon);\n        }\n    }\n\n    let mut style = Style::light_bg();\n    style.loading_tips = settings.loading_tips.unwrap_or_else(Text::new);\n\n    let monitor_scale_factor = prerender_innards.monitor_scale_factor();\n    let prerender = Prerender {\n        assets: Assets::new(\n            style.clone(),\n            settings.assets_base_url,\n            settings.assets_are_gzipped,\n            settings.read_svg,\n        ),\n        num_uploads: Cell::new(0),\n        inner: prerender_innards,\n        scale_factor: Cell::new(settings.scale_factor.unwrap_or(monitor_scale_factor)),\n    };\n    if let Some(min_width) = settings.require_minimum_width {\n        let initial_size = prerender.window_size();\n        if initial_size.width < min_width && settings.scale_factor.is_none() {\n            warn!(\n                \"Monitor scale factor is {}, screen window is {}, but the application requires \\\n                 {}. Overriding the scale factor to 1.\",\n                monitor_scale_factor, initial_size.width, min_width\n            );\n            prerender.scale_factor.set(1.0);\n        }\n    }\n\n    let initial_size = prerender.window_size();\n    let mut canvas = Canvas::new(initial_size, settings.canvas_settings);\n    prerender.window_resized(initial_size);\n\n    timer.start(\"setup app\");\n    let (shared_app_state, states) = {\n        let mut ctx = EventCtx {\n            fake_mouseover: true,\n            input: UserInput::new(Event::NoOp, &canvas),\n            canvas: &mut canvas,\n            prerender: &prerender,\n            style: &mut style,\n            updates_requested: vec![],\n            canvas_movement_called: false,\n            focus_owned_by: None,\n            next_focus_owned_by: None,\n        };\n        if settings.load_default_textures {\n            timer.start(\"load default texture\");\n            ctx.set_texture(\n                include_bytes!(\"../textures/spritesheet.png\").to_vec(),\n                (64, 64),\n                (16.0, 16.0),\n            );\n            timer.stop(\"load default texture\");\n        }\n        make_app(&mut ctx)\n    };\n    timer.stop(\"setup app\");\n    let app = App {\n        states,\n        shared_app_state,\n    };\n    timer.done();\n\n    let mut state = State {\n        app,\n        canvas,\n        style,\n        focus_owned_by: None,\n    };\n\n    let dump_raw_events = settings.dump_raw_events;\n\n    let mut running = true;\n    let mut last_update = Instant::now();\n    // The user will not manage to click immediately after the window opens, so this initial value is simpler than an `Option<Instant>`\n    let mut previous_left_click_at = Instant::now();\n\n    // Remember the last keycode, so that we can suppress a sequence like Alt+Tab\n    let mut previous_keycode = None;\n    event_loop.run(move |event, _, control_flow| {\n        if dump_raw_events {\n            debug!(\"Event: {:?}\", event);\n        }\n        let ev = match event {\n            winit::event::Event::WindowEvent {\n                event: winit::event::WindowEvent::CloseRequested,\n                ..\n            } => {\n                // ControlFlow::Exit cleanly shuts things down, meaning on larger maps, lots of\n                // GPU stuff is dropped. Better to just abort violently and let the OS clean\n                // up.\n                state.app.shared_app_state.before_quit(&state.canvas);\n                std::process::exit(0);\n            }\n            winit::event::Event::WindowEvent { event, .. } => {\n                use winit::event::VirtualKeyCode;\n\n                if let winit::event::WindowEvent::KeyboardInput { input, .. } = event {\n                    // TODO If someone happens to press and release alt, then press tab, we will\n                    // incorrectly suppress the tab. Attempts to add timing haven't worked so far,\n                    // so just accept this.\n                    if previous_keycode == Some(VirtualKeyCode::LAlt)\n                        && input.virtual_keycode == Some(VirtualKeyCode::Tab)\n                    {\n                        debug!(\"Skipping alt+tab event\");\n                        previous_keycode = input.virtual_keycode;\n                        return;\n                    }\n                    previous_keycode = input.virtual_keycode;\n                }\n\n                let scale_factor = prerender.get_scale_factor();\n                if let Some(ev) =\n                    Event::from_winit_event(event, scale_factor, previous_left_click_at)\n                {\n                    ev\n                } else {\n                    // Don't touch control_flow if we got an irrelevant event\n                    return;\n                }\n            }\n            winit::event::Event::RedrawRequested(_) => {\n                state.draw(&prerender, false);\n                prerender.num_uploads.set(0);\n                return;\n            }\n            winit::event::Event::MainEventsCleared => {\n                // We might've switched to InputOnly after the WaitUntil was requested.\n                if running {\n                    Event::Update(Duration::realtime_elapsed(last_update))\n                } else {\n                    return;\n                }\n            }\n            _ => {\n                return;\n            }\n        };\n\n        // We want a max of UPDATE_FREQUENCY between updates, so measure the update time before\n        // doing the work (which takes time).\n        match ev {\n            Event::Update(_) => {\n                last_update = Instant::now();\n                *control_flow =\n                    winit::event_loop::ControlFlow::WaitUntil(Instant::now() + UPDATE_FREQUENCY);\n            }\n            Event::LeftMouseButtonUp {\n                is_double_click: false,\n            } => {\n                previous_left_click_at = Instant::now();\n            }\n            _ => {}\n        }\n\n        let (mut updates, input_used) = state.event(ev, &prerender);\n\n        if input_used {\n            prerender.request_redraw();\n        }\n\n        if updates.is_empty() {\n            updates.push(UpdateType::InputOnly);\n        }\n        for update in updates {\n            match update {\n                UpdateType::InputOnly => {\n                    running = false;\n                    *control_flow = winit::event_loop::ControlFlow::Wait;\n                }\n                UpdateType::Game => {\n                    // If we just unpaused, then don't act as if lots of time has passed.\n                    if !running {\n                        last_update = Instant::now();\n                        *control_flow = winit::event_loop::ControlFlow::WaitUntil(\n                            Instant::now() + UPDATE_FREQUENCY,\n                        );\n                    }\n\n                    running = true;\n                }\n                UpdateType::Pan => {}\n                UpdateType::ScreenCaptureEverything { dir, zoom, dims } => {\n                    if let Err(err) =\n                        screenshot_everything(&mut state, &dir, &prerender, zoom, dims)\n                    {\n                        error!(\"Couldn't screenshot everything: {}\", err);\n                    }\n                }\n            }\n        }\n    });\n}\n\n\n# widgetry/src/canvas.rs:\nuse std::cell::RefCell;\nuse std::collections::HashSet;\n\nuse serde::{Deserialize, Serialize};\n\nuse geom::{Bounds, Pt2D};\n\nuse crate::{Key, ScreenDims, ScreenPt, ScreenRectangle, UpdateType, UserInput};\n\n// Click and release counts as a normal click, not a drag, if the distance between click and\n// release is less than this.\nconst DRAG_THRESHOLD: f64 = 5.0;\n\nconst PAN_SPEED: f64 = 15.0;\n\nconst PANNING_THRESHOLD: f64 = 25.0;\n\npub struct Canvas {\n    // All of these f64's are in screen-space, so do NOT use Pt2D.\n    // Public for saving/loading... should probably do better\n    pub cam_x: f64,\n    pub cam_y: f64,\n    pub cam_zoom: f64,\n\n    // TODO Should this become Option<ScreenPt>?\n    pub(crate) cursor: ScreenPt,\n    pub(crate) window_has_cursor: bool,\n\n    // Only for drags starting on the map. Only used to pan the map. (Last event, original)\n    pub(crate) drag_canvas_from: Option<(ScreenPt, ScreenPt)>,\n    drag_just_ended: bool,\n\n    pub window_width: f64,\n    pub window_height: f64,\n\n    // TODO Proper API for setting these\n    pub map_dims: (f64, f64),\n    pub settings: CanvasSettings,\n\n    // TODO Bit weird and hacky to mutate inside of draw() calls.\n    pub(crate) covered_areas: RefCell<Vec<ScreenRectangle>>,\n\n    // Kind of just widgetry state awkwardly stuck here...\n    pub(crate) keys_held: HashSet<Key>,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct CanvasSettings {\n    pub invert_scroll: bool,\n    pub touchpad_to_move: bool,\n    pub edge_auto_panning: bool,\n    pub keys_to_pan: bool,\n    pub gui_scroll_speed: usize,\n    // TODO Ideally this would be an f64, but elsewhere we use it in a Spinner. Until we override\n    // the Display trait to do some rounding, floating point increments render pretty horribly.\n    pub canvas_scroll_speed: usize,\n    /// Some map-space elements are drawn differently when unzoomed and zoomed. This specifies the canvas\n    /// zoom level where they switch. The concept of \"unzoomed\" and \"zoomed\" is used by\n    /// `ToggleZoomed`.\n    pub min_zoom_for_detail: f64,\n}\n\nimpl CanvasSettings {\n    pub fn new() -> CanvasSettings {\n        CanvasSettings {\n            invert_scroll: false,\n            touchpad_to_move: false,\n            edge_auto_panning: false,\n            keys_to_pan: false,\n            gui_scroll_speed: 5,\n            canvas_scroll_speed: 10,\n            min_zoom_for_detail: 4.0,\n        }\n    }\n}\n\nimpl Canvas {\n    pub(crate) fn new(initial_dims: ScreenDims, settings: CanvasSettings) -> Canvas {\n        Canvas {\n            cam_x: 0.0,\n            cam_y: 0.0,\n            cam_zoom: 1.0,\n\n            cursor: ScreenPt::new(0.0, 0.0),\n            window_has_cursor: true,\n\n            drag_canvas_from: None,\n            drag_just_ended: false,\n\n            window_width: initial_dims.width,\n            window_height: initial_dims.height,\n\n            map_dims: (0.0, 0.0),\n            settings,\n\n            covered_areas: RefCell::new(Vec::new()),\n\n            keys_held: HashSet::new(),\n        }\n    }\n\n    pub fn max_zoom(&self) -> f64 {\n        50.0\n    }\n\n    pub fn min_zoom(&self) -> f64 {\n        let percent_window = 0.8;\n        (percent_window * self.window_width / self.map_dims.0)\n            .min(percent_window * self.window_height / self.map_dims.1)\n    }\n\n    pub fn is_max_zoom(&self) -> bool {\n        self.cam_zoom >= self.max_zoom()\n    }\n\n    pub fn is_min_zoom(&self) -> bool {\n        self.cam_zoom <= self.min_zoom()\n    }\n\n    pub(crate) fn handle_event(&mut self, input: &mut UserInput) -> Option<UpdateType> {\n        // Can't start dragging or zooming on top of covered area\n        if let Some(map_pt) = self.get_cursor_in_map_space() {\n            if self.settings.touchpad_to_move {\n                if let Some((scroll_x, scroll_y)) = input.get_mouse_scroll() {\n                    if self.keys_held.contains(&Key::LeftControl) {\n                        self.zoom(scroll_y, self.cursor);\n                    } else {\n                        // Woo, inversion is different for the two. :P\n                        self.cam_x -= scroll_x * PAN_SPEED;\n                        self.cam_y -= scroll_y * PAN_SPEED;\n                    }\n                }\n            } else {\n                if input.left_mouse_button_pressed() {\n                    self.drag_canvas_from = Some((self.get_cursor(), self.get_cursor()));\n                }\n\n                if let Some((_, scroll)) = input.get_mouse_scroll() {\n                    self.zoom(scroll, self.cursor);\n                }\n            }\n\n            if self.settings.keys_to_pan {\n                if input.pressed(Key::LeftArrow) {\n                    self.cam_x -= PAN_SPEED;\n                }\n                if input.pressed(Key::RightArrow) {\n                    self.cam_x += PAN_SPEED;\n                }\n                if input.pressed(Key::UpArrow) {\n                    self.cam_y -= PAN_SPEED;\n                }\n                if input.pressed(Key::DownArrow) {\n                    self.cam_y += PAN_SPEED;\n                }\n                if input.pressed(Key::Q) {\n                    self.zoom(\n                        1.0,\n                        ScreenPt::new(self.window_width / 2.0, self.window_height / 2.0),\n                    );\n                }\n                if input.pressed(Key::W) {\n                    self.zoom(\n                        -1.0,\n                        ScreenPt::new(self.window_width / 2.0, self.window_height / 2.0),\n                    );\n                }\n            }\n\n            if input.left_mouse_double_clicked() {\n                self.zoom(8.0, self.map_to_screen(map_pt));\n            }\n        }\n\n        // If we start the drag on the map and move the mouse off the map, keep dragging.\n        if let Some((click, orig)) = self.drag_canvas_from {\n            let pt = self.get_cursor();\n            self.cam_x += click.x - pt.x;\n            self.cam_y += click.y - pt.y;\n            self.drag_canvas_from = Some((pt, orig));\n\n            if input.left_mouse_button_released() {\n                let (_, orig) = self.drag_canvas_from.take().unwrap();\n                let dist = ((pt.x - orig.x).powi(2) + (pt.y - orig.y).powi(2)).sqrt();\n                if dist > DRAG_THRESHOLD {\n                    self.drag_just_ended = true;\n                }\n            }\n        } else if self.drag_just_ended {\n            self.drag_just_ended = false;\n        } else {\n            let cursor_screen_pt = self.get_cursor().to_pt();\n            let cursor_map_pt = self.screen_to_map(self.get_cursor());\n            let inner_bounds = self.get_inner_bounds();\n            let map_bounds = self.get_map_bounds();\n            if self.settings.edge_auto_panning\n                && !inner_bounds.contains(cursor_screen_pt)\n                && map_bounds.contains(cursor_map_pt)\n                && input.nonblocking_is_update_event().is_some()\n            {\n                let center_pt = self.center_to_screen_pt().to_pt();\n                let displacement_x = cursor_screen_pt.x() - center_pt.x();\n                let displacement_y = cursor_screen_pt.y() - center_pt.y();\n                let displacement_magnitude =\n                    f64::sqrt(displacement_x.powf(2.0) + displacement_y.powf(2.0));\n                let displacement_unit_x = displacement_x / displacement_magnitude;\n                let displacement_unit_y = displacement_y / displacement_magnitude;\n                // Add displacement along each axis\n                self.cam_x += displacement_unit_x * PAN_SPEED;\n                self.cam_y += displacement_unit_y * PAN_SPEED;\n                return Some(UpdateType::Pan);\n            }\n        }\n        None\n    }\n\n    pub fn center_zoom(&mut self, delta: f64) {\n        self.zoom(delta, self.center_to_screen_pt())\n    }\n\n    pub fn zoom(&mut self, delta: f64, focus: ScreenPt) {\n        let old_zoom = self.cam_zoom;\n        // By popular request, some limits ;)\n        self.cam_zoom = 1.1_f64\n            .powf(old_zoom.log(1.1) + delta * (self.settings.canvas_scroll_speed as f64 / 10.0))\n            .max(self.min_zoom())\n            .min(self.max_zoom());\n\n        // Make screen_to_map of the focus point still point to the same thing after\n        // zooming.\n        self.cam_x = ((self.cam_zoom / old_zoom) * (focus.x + self.cam_x)) - focus.x;\n        self.cam_y = ((self.cam_zoom / old_zoom) * (focus.y + self.cam_y)) - focus.y;\n    }\n\n    pub(crate) fn start_drawing(&self) {\n        self.covered_areas.borrow_mut().clear();\n    }\n\n    // TODO Only public for the OSD. :(\n    pub fn mark_covered_area(&self, rect: ScreenRectangle) {\n        self.covered_areas.borrow_mut().push(rect);\n    }\n\n    // Might be hovering anywhere.\n    pub fn get_cursor(&self) -> ScreenPt {\n        self.cursor\n    }\n\n    pub fn get_cursor_in_screen_space(&self) -> Option<ScreenPt> {\n        if self.window_has_cursor && self.get_cursor_in_map_space().is_none() {\n            Some(self.get_cursor())\n        } else {\n            None\n        }\n    }\n\n    pub fn get_cursor_in_map_space(&self) -> Option<Pt2D> {\n        if self.window_has_cursor {\n            let pt = self.get_cursor();\n\n            for rect in self.covered_areas.borrow().iter() {\n                if rect.contains(pt) {\n                    return None;\n                }\n            }\n\n            Some(self.screen_to_map(pt))\n        } else {\n            None\n        }\n    }\n\n    pub fn screen_to_map(&self, pt: ScreenPt) -> Pt2D {\n        Pt2D::new(\n            (pt.x + self.cam_x) / self.cam_zoom,\n            (pt.y + self.cam_y) / self.cam_zoom,\n        )\n    }\n\n    pub fn center_to_screen_pt(&self) -> ScreenPt {\n        ScreenPt::new(self.window_width / 2.0, self.window_height / 2.0)\n    }\n\n    pub fn center_to_map_pt(&self) -> Pt2D {\n        self.screen_to_map(self.center_to_screen_pt())\n    }\n\n    pub fn center_on_map_pt(&mut self, pt: Pt2D) {\n        self.cam_x = (pt.x() * self.cam_zoom) - (self.window_width / 2.0);\n        self.cam_y = (pt.y() * self.cam_zoom) - (self.window_height / 2.0);\n    }\n\n    pub fn map_to_screen(&self, pt: Pt2D) -> ScreenPt {\n        ScreenPt::new(\n            (pt.x() * self.cam_zoom) - self.cam_x,\n            (pt.y() * self.cam_zoom) - self.cam_y,\n        )\n    }\n\n    // the inner bound tells us whether auto-panning should or should not take place\n    fn get_inner_bounds(&self) -> Bounds {\n        let mut b = Bounds::new();\n        b.update(ScreenPt::new(PANNING_THRESHOLD, PANNING_THRESHOLD).to_pt());\n        b.update(\n            ScreenPt::new(\n                self.window_width - PANNING_THRESHOLD,\n                self.window_height - PANNING_THRESHOLD,\n            )\n            .to_pt(),\n        );\n        b\n    }\n\n    pub fn get_window_dims(&self) -> ScreenDims {\n        ScreenDims::new(self.window_width, self.window_height)\n    }\n\n    fn get_map_bounds(&self) -> Bounds {\n        let mut b = Bounds::new();\n        b.update(Pt2D::new(0.0, 0.0));\n        b.update(Pt2D::new(self.map_dims.0, self.map_dims.1));\n        b\n    }\n\n    pub fn get_screen_bounds(&self) -> Bounds {\n        let mut b = Bounds::new();\n        b.update(self.screen_to_map(ScreenPt::new(0.0, 0.0)));\n        b.update(self.screen_to_map(ScreenPt::new(self.window_width, self.window_height)));\n        b\n    }\n\n    pub(crate) fn align_window(\n        &self,\n        dims: ScreenDims,\n        horiz: HorizontalAlignment,\n        vert: VerticalAlignment,\n    ) -> ScreenPt {\n        let x1 = match horiz {\n            HorizontalAlignment::Left => 0.0,\n            HorizontalAlignment::LeftInset => INSET,\n            HorizontalAlignment::Center => (self.window_width - dims.width) / 2.0,\n            HorizontalAlignment::Right => self.window_width - dims.width,\n            HorizontalAlignment::RightOf(x) => x,\n            HorizontalAlignment::RightInset => self.window_width - dims.width - INSET,\n            HorizontalAlignment::Percent(pct) => pct * self.window_width,\n            HorizontalAlignment::Centered(x) => x - (dims.width / 2.0),\n        };\n        let y1 = match vert {\n            VerticalAlignment::Top => 0.0,\n            VerticalAlignment::TopInset => INSET,\n            VerticalAlignment::Center => (self.window_height - dims.height) / 2.0,\n            VerticalAlignment::Bottom => self.window_height - dims.height,\n            VerticalAlignment::BottomInset => self.window_height - dims.height - INSET,\n            // TODO Hack\n            VerticalAlignment::BottomAboveOSD => self.window_height - dims.height - 60.0,\n            VerticalAlignment::Percent(pct) => pct * self.window_height,\n            VerticalAlignment::Above(y) => y - dims.height,\n            VerticalAlignment::Below(y) => y,\n        };\n        ScreenPt::new(x1, y1)\n    }\n\n    pub fn is_unzoomed(&self) -> bool {\n        self.cam_zoom < self.settings.min_zoom_for_detail\n    }\n\n    pub fn is_zoomed(&self) -> bool {\n        self.cam_zoom >= self.settings.min_zoom_for_detail\n    }\n\n    pub(crate) fn is_dragging(&self) -> bool {\n        // This could be called before or after handle_event. So we need to repeat the threshold\n        // check here! Alternatively, we could this upfront in runner.\n        if self.drag_just_ended {\n            return true;\n        }\n        if let Some((_, orig)) = self.drag_canvas_from {\n            let pt = self.get_cursor();\n            let dist = ((pt.x - orig.x).powi(2) + (pt.y - orig.y).powi(2)).sqrt();\n            if dist > DRAG_THRESHOLD {\n                return true;\n            }\n        }\n        false\n    }\n}\n\nconst INSET: f64 = 16.0;\n\n#[derive(Clone, Copy, Debug, PartialEq)]\npub enum HorizontalAlignment {\n    Left,\n    LeftInset,\n    Center,\n    Right,\n    RightOf(f64),\n    RightInset,\n    Percent(f64),\n    Centered(f64),\n}\n\n#[derive(Clone, Copy, Debug, PartialEq)]\npub enum VerticalAlignment {\n    Top,\n    TopInset,\n    Center,\n    Bottom,\n    BottomInset,\n    BottomAboveOSD,\n    Percent(f64),\n    Above(f64),\n    Below(f64),\n}\n\n\n# piggyback/Cargo.toml:\n[package]\nname = \"piggyback\"\nversion = \"0.1.0\"\nauthors = [\"Dustin Carlino <dabreegster@gmail.com>\"]\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\", \"lib\"]\n\n[features]\nwasm = [\"getrandom/js\", \"js-sys\", \"map_gui/wasm\", \"wasm-bindgen\", \"web-sys\", \"widgetry/wasm-backend\"]\n\n[dependencies]\nabstio = { path = \"../abstio\" }\nabstutil = { path = \"../abstutil\" }\ngeom = { workspace = true }\ngetrandom = { workspace = true, optional = true }\njs-sys = { version = \"0.3.51\", optional = true }\nlog = { workspace = true }\nmap_gui= { path = \"../map_gui\" }\nmap_model = { path = \"../map_model\" }\nsim = { path = \"../sim\" }\nwasm-bindgen = { workspace = true, optional = true }\nweb-sys = { workspace = true, optional = true }\nwidgetry = { path = \"../widgetry\" }\n\n\n# piggyback/bundle_static_files.sh:\n#!/bin/bash\n# This creates a .zip with all of the files needed to serve a copy of the Mapbox demo.\n\nset -x\nset -e\n\nwasm-pack build --release --target web -- --features wasm\n\nmkdir mapbox_demo\ncp -Rv index.html serve_locally.py pkg mapbox_demo\n\nmkdir -p mapbox_demo/data/system/us/seattle/maps\nmkdir -p mapbox_demo/data/system/de/berlin/maps\n# Just include a few maps\ncp ../data/system/us/seattle/maps/montlake.bin mapbox_demo/data/system/us/seattle/maps\ncp ../data/system/de/berlin/maps/neukolln.bin mapbox_demo/data/system/de/berlin/maps\n\n# Uncomment with caution!\n# Note this embeds a tiny slice of the data/ directory underneath mapbox_demo.\n# The S3 bucket has gzipped map files, but the JS / Rust layers don't handle\n# reading both yet.\n#aws s3 sync mapbox_demo s3://abstreet/dev/mapbox_demo\n"}, {"role": "user", "content": "\nCreate a detailed setup and development documentation section.\n\nStart with the title '## Setup and Development'.\n\nInclude subsections using '### [Subsection Name]' format. Examples of subsections may include (but are not limited to):\n- Prerequisites\n- Environment Setup\n- Dependencies\n- Build Process\n- Configuration Files\n- Code Style and Standards\n\nProvide clear, step-by-step instructions and explanations for each subsection.\n\nIMPORTANT: The output should be directly suitable for a markdown file without any additional explanations or markdown code block tags.\n"}]}